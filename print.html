<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01. object.html"><strong aria-hidden="true">1.</strong> Объект</a></li><li class="chapter-item expanded "><a href="02. alignment.html"><strong aria-hidden="true">2.</strong> Выравнивание</a></li><li class="chapter-item expanded "><a href="03. storage duration.html"><strong aria-hidden="true">3.</strong> Типы размещения</a></li><li class="chapter-item expanded "><a href="04. namespaces%2C aliases%2C adl.html"><strong aria-hidden="true">4.</strong> Пространства имен, алиасы, ADL</a></li><li class="chapter-item expanded "><a href="05. inline%2C ODR and linkage.html"><strong aria-hidden="true">5.</strong> Inline, ODR и связывание</a></li><li class="chapter-item expanded "><a href="06. refs and pointers.html"><strong aria-hidden="true">6.</strong> Ссылки и указатели</a></li><li class="chapter-item expanded "><a href="07. value categories%2C move.html"><strong aria-hidden="true">7.</strong> Категории значений, move-семантика</a></li><li class="chapter-item expanded "><a href="08. references and forward.html"><strong aria-hidden="true">8.</strong> Ссылки и std::forward</a></li><li class="chapter-item expanded "><a href="09. inheritance%2C virtual%2C cast.html"><strong aria-hidden="true">9.</strong> Наследование, virtual, приведение типов</a></li><li class="chapter-item expanded "><a href="10. templates.html"><strong aria-hidden="true">10.</strong> Шаблоны</a></li><li class="chapter-item expanded "><a href="11. variadic templates.html"><strong aria-hidden="true">11.</strong> Variadic templates</a></li><li class="chapter-item expanded "><a href="12. exceptions%2C noexcept.html"><strong aria-hidden="true">12.</strong> Исключения, noexcept</a></li><li class="chapter-item expanded "><a href="13. constexpr%2C consteval%2C if.html"><strong aria-hidden="true">13.</strong> constexpr, consteval, if</a></li><li class="chapter-item expanded "><a href="14. decltype%2C declval%2C auto.html"><strong aria-hidden="true">14.</strong> decltype, declval, auto</a></li><li class="chapter-item expanded "><a href="15. SFINAE.html"><strong aria-hidden="true">15.</strong> SFINAE</a></li><li class="chapter-item expanded "><a href="16. RAII%2C smart pointers.html"><strong aria-hidden="true">16.</strong> RAII, умные указатели</a></li><li class="chapter-item expanded "><a href="17. EBO%2C RVO%2C PGO%2C LTO.html"><strong aria-hidden="true">17.</strong> EBO, RVO, PGO, LTO</a></li><li class="chapter-item expanded "><a href="18. lambda.html"><strong aria-hidden="true">18.</strong> Лямбда-функции</a></li><li class="chapter-item expanded "><a href="19. type erasure pattern.html"><strong aria-hidden="true">19.</strong> Type erasure паттерн</a></li><li class="chapter-item expanded "><a href="20. threading problems.html"><strong aria-hidden="true">20.</strong> Проблемы с многопоточностью</a></li><li class="chapter-item expanded "><a href="21. atomics%2C memory order.html"><strong aria-hidden="true">21.</strong> std::atomic, memory_order</a></li><li class="chapter-item expanded "><a href="22. volatile.html"><strong aria-hidden="true">22.</strong> Квалификатор volatile</a></li><li class="chapter-item expanded "><a href="23. promise%2C future%2C async.html"><strong aria-hidden="true">23.</strong> std::promise, std::future, std::async</a></li><li class="chapter-item expanded "><a href="24. coroutines.html"><strong aria-hidden="true">24.</strong> Корутины</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Объект"><a class="header" href="#Объект">Объект</a></h1>
<p>Объект - это участок памяти, у которого есть</p>
<ol>
<li>Размер</li>
<li>Выравнивание</li>
<li>Тип размещения</li>
<li>Время жизни</li>
<li>Тип</li>
<li>Значение (может быть не определено)</li>
<li>Имя (необязательно)</li>
</ol>
<p>Объектами не являются</p>
<ul>
<li>Значения</li>
<li>Ссылки</li>
<li>Функции</li>
<li>Перечисление (<code>enum</code>)</li>
<li>Типы</li>
<li>Нестатические типы класса</li>
<li>Шаблоны</li>
<li>Специализация класса или функции</li>
<li>Namespace</li>
<li>Parameter pack</li>
<li><code>this</code></li>
</ul>
<p>Гарантируется, что два объекта, время жизни которых пересекаются имеют разный адрес в памяти (если один их них не является подобъектом другого).</p>
<p>Размер любого полного (<code>complete</code>) объекта должен быть больше нуля.</p>
<pre><code class="language-cpp">struct empty {};

int main() {
    std::cout &lt;&lt; sizeof(empty) &lt;&lt; std::endl; // output: 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Выравнивание"><a class="header" href="#Выравнивание">Выравнивание</a></h1>
<p>Выравнивание - это ограничение на то, с какой ячейки памяти по счету может храниться первый бит объекта. Выравнивание необходимо для ускорения доступа к памяти, к примеру, на архитектуре x86-64. Невыровненные данные обрабатываться могут, но это может быть медленно на некоторых архитектурах.</p>
<p>Также его важно учитывать при использовании векторных инструкций процессора, которые значительно ускоряют вычисления в некоторых случаях. Невыровненные данные в этом случае могут привести к генерации аппаратного исключения. Для справки, для SSE выравнивание должно составлять 16 байт, для AVX - 32 байта.</p>
<p>Выравнивание в 16 единиц означает, что валидным адресом для доступа будет только значение, делящееся на 16.</p>
<p>Выравнивание существует у каждого объекта. Для задания своего выравнивания в байтах у соответствующей переменной существует ключевое слово <code>alignas</code>, которое принимает степени двойки: 2, 4, 8, 16, 32, 64, 128 и так далее.</p>
<pre><code class="language-cpp">alignas(16) int a[4];
alignas(1024) int b[4];
</code></pre>
<p>Получить выравнивание объекта в compile-time можно с помощью ключевого слова <code>alignof</code>, причем возвращается наибольшая из степеней двойки.</p>
<pre><code class="language-cpp">static_assert(alignof(b) == 16); // fail
static_assert(alignof(b) == 1024); // OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типы-размещения"><a class="header" href="#Типы-размещения">Типы размещения</a></h1>
<h3 id="Спецификаторы"><a class="header" href="#Спецификаторы">Спецификаторы</a></h3>
<ul>
<li><code>(no specifier)</code> - автоматическое</li>
<li><code>static</code> - статическое (внутреннее связывание)</li>
<li><code>extern</code> - так же статическое (внешнее связывание)</li>
<li><code>thread_local</code> - тред-локальное размещение</li>
</ul>
<h4 id="Автоматическое-размещение"><a class="header" href="#Автоматическое-размещение">Автоматическое размещение</a></h4>
<p>Память под объект аллоцируется на стеке в начале открыващегося блока кода и деаллоцируется в конце.</p>
<h4 id="Статическое-размещение"><a class="header" href="#Статическое-размещение">Статическое размещение</a></h4>
<p>Память под объект аллоцируется перед исполнением программы и деаллоцируется в конце.</p>
<p>Если переменная со статическим размещением не инициализируется разработчиком, то она будет проинициализирована нулем соответствущего типа.</p>
<h4 id="Тред-локальное-размещение"><a class="header" href="#Тред-локальное-размещение">Тред-локальное размещение</a></h4>
<p>Память под объект аллоцируется при создании потока и деаллоцируется при его завершении. Каждый поток обладает собственным экземпляром объекта.</p>
<h4 id="Динамическое-размещение"><a class="header" href="#Динамическое-размещение">Динамическое размещение</a></h4>
<p>Память под объект аллоцируется и деаллоцируется по запросу программы при помощи специальных функций. При закрытии программы все недеаллоцированные ранее области памяти деаллоцируются средствами ОС.</p>
<p>(не уверен в последнем пункте, так как не силен за shared memory).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Пространства-имен-алиасы-adl"><a class="header" href="#Пространства-имен-алиасы-adl">Пространства имен, алиасы, ADL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-odr-и-связывание"><a class="header" href="#inline-odr-и-связывание">Inline, ODR и связывание</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ссылки-и-указатели"><a class="header" href="#Ссылки-и-указатели">Ссылки и указатели</a></h1>
<p>Ссылка - это псевдоним к определенной ранее переменной.
Указатель - это объект, значением которого является адрес ячейки памяти.</p>
<p>Разница?</p>
<h4 id="Инициализация"><a class="header" href="#Инициализация">Инициализация</a></h4>
<p>Ссылку обязательно инициализировать. Она не может указывать вникуда или быть пустой, в отличие от указателя, которому задавать начальное значение необязательно.</p>
<h4 id="Изменение-значения"><a class="header" href="#Изменение-значения">Изменение значения</a></h4>
<p>Ссылка не может быть переопределена, вместо этого присвоится значение переменной, на которую ссылка ссылается, если она не константная. Присваивать же новое значение указателю можно, если он не константный.</p>
<h4 id="Взятие-адреса"><a class="header" href="#Взятие-адреса">Взятие адреса</a></h4>
<p>Ссылка - псевдоним к переменной, а не объект. Взятие адреса от ссылки будет возвращать адрес объекта, на который ссылка ссылается. Взятие же адреса указателя будет возвращать адрес указателя, а не объекта, на который указатель ссылается.</p>
<p>По стандарту ссылка - не объект, но при определенных условиях, ссылки могут компилироваться в указатели.</p>
<p>Рекомендация: используйте ссылки вместо указателей, если вам не нужно передавать пустое значение (читай, <code>nullptr</code>).</p>
<h2 id="Интересное-про-ссылки"><a class="header" href="#Интересное-про-ссылки">Интересное про ссылки</a></h2>
<h3 id="Краткие-факты"><a class="header" href="#Краткие-факты">Краткие факты</a></h3>
<ul>
<li>Ссылки на ссылку не бывает. Они коллапсируют в одну.</li>
<li>Ссылки типа <code>void</code> не бывает.</li>
<li>Ссылка может продлить время жизни объекта, если это <code>lvalue</code>-ссылка на const или <code>rvalue</code>-ссылка.</li>
</ul>
<h3 id="dangling-reference"><a class="header" href="#dangling-reference">Dangling reference</a></h3>
<p>Ссылки были созданы, чтобы сделать указатели безопаснее, но даже их можно сломать.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int&amp; bar() {
    int n = 10;
    return n;
}

int main() {
    int&amp; i = bar();
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
<p>Функция <code>bar()</code> вернет ссылку на локальную переменную, которая уничтожится при выходе из нее. Соответственно, такая ссылка будет невалидной и операции с ней - это undefined behavior.</p>
<p>Но вот так делать можно, конечно.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

const int&amp; bar(const int&amp; a) {
    return a;
}

int main() {
    const int&amp; i = bar(42);
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
<h3 id="Передача-массива-по-ссылке"><a class="header" href="#Передача-массива-по-ссылке">Передача массива по ссылке</a></h3>
<p>Не секрет, что для работы с массивами можно использовать указатели, но в определение типа таких указателей не входит размер массива. При передаче указателя в функцию, информацию о размере нужно передавать отдельно. Чтобы с этим не париться, можно сделать ссылку на массив с фиксированным размером.</p>
<pre><code class="language-cpp">#include &lt;type_traits&gt;

// Конвертирует строковый литерал в число
template &lt;size_t N&gt;
int convert(const char (&amp;in)[N]) {
    int res = 0;
    for (const char * c = in; *c; ++c) {
        (res *= 10) += *c - '0';
    }
    return res;
}

// Вычисляет длину массива
template &lt;typename T, size_t N&gt;
size_t len(T (&amp;a)[N]) {
    return N;
}
</code></pre>
<p>Остальные фишки ссылок будут в другой заметке.</p>
<h2 id="Интересное-про-указатели"><a class="header" href="#Интересное-про-указатели">Интересное про указатели</a></h2>
<h3 id="Краткие-факты-1"><a class="header" href="#Краткие-факты-1">Краткие факты</a></h3>
<ul>
<li>Можно сделать указатель на указатель на указатель ...</li>
<li>Поддерживают арифметику (только указатели в рамках одного массива. остальное - UB)</li>
</ul>
<h3 id="Указатели-на-массивы-фиксированной-длины"><a class="header" href="#Указатели-на-массивы-фиксированной-длины">Указатели на массивы фиксированной длины</a></h3>
<pre><code class="language-cpp">int (*a)[2];                  // create pointer to int[2]
int b[2];
int c[2];

a = new int[2];               // compile error (returns int*)
a = &amp;b;                       // OK (returns int(*)[2])
a = (int(*)[2]) (new int[2]); // OK
a = &amp;c;                       // compile error (returns int(*)[3])
</code></pre>
<h3 id="Многомерные-массивы-на-стеке"><a class="header" href="#Многомерные-массивы-на-стеке">Многомерные массивы на стеке</a></h3>
<p>При объявлении многомерных массивов на стеке память выделяется непрерывно, что позволяет компилятору при индексации делать прыжок по указателю единожды.</p>
<pre><code class="language-cpp">int x[10][10];   // выделенный на стеке многомерный массив
int a = x[2][3]; // один прыжок
</code></pre>
<p>Но при индексации от указателя на него программа будет совершать честные прыжки в количестве измерений.</p>
<pre><code class="language-cpp">int **y = x;
int b = y[2][3]; // два прыжка
</code></pre>
<h3 id="Как-читать-мешанину-со-словом-const"><a class="header" href="#Как-читать-мешанину-со-словом-const">Как читать мешанину со словом const</a></h3>
<p>Ключевое слово <code>const</code> относится к тому, что слева, если не в начале строки, иначе к тому, что справа.</p>
<pre><code class="language-cpp">int a = 42;
const int b;              // нет инициализации, compile error
const int c = a;          // константный int
int const d = a;          // то же самое

const int * e = &amp;a;       // изменяемый указатель на неизменяемый int
int const * f = &amp;a;       // то же самое

int * const g = &amp;a;       // неизменяемый указатель на изменяемый int
const int * const h = &amp;a; // константный указатель на константу
</code></pre>
<h3 id="Указатель-на-функцию"><a class="header" href="#Указатель-на-функцию">Указатель на функцию</a></h3>
<pre><code class="language-cpp">double sum(int a, long b) {
    return a + b;
}

double (*ptr)(int, long) = sum;
double (*ptr)(int, long) = &amp;sum; // эквивалентно

double c = (*ptr)(1, 2l);
double c = ptr(1, 2l); // эквивалентно
</code></pre>
<h3 id="Массив-указателей-на-массив"><a class="header" href="#Массив-указателей-на-массив">Массив указателей на массив</a></h3>
<pre><code class="language-cpp">int A[5][5];
int B[5][5];
int (*C[])[5][5] = {&amp;A, &amp;B};
</code></pre>
<h3 id="Пример-от-Артема-К"><a class="header" href="#Пример-от-Артема-К">Пример от Артема К</a></h3>
<pre><code class="language-cpp">double (* (* x[10]) (int &amp;))[5];
</code></pre>
<p>x — это массив из 10 указателей на функции, которые принимают аргументом <code>int&amp;</code>, а возвращают массив из 5 <code>double</code>.</p>
<h3 id="Как-парсить-подобные-вещи"><a class="header" href="#Как-парсить-подобные-вещи">Как парсить подобные вещи</a></h3>
<ul>
<li>Парсим изнутри, начиная с имени переменной</li>
<li>Идем вправо, потом влево</li>
<li>Потом на следующий уровень наружу</li>
</ul>
<p>Пример:</p>
<pre><code class="language-cpp">void * (* y[5])(char);
</code></pre>
<p>y — это:</p>
<ol>
<li>массив из пяти</li>
<li>указателей</li>
<li>на функцию, принимающую char</li>
<li>и возвращающую void *</li>
</ol>
<h3 id="Пример-от-Артема-К-1"><a class="header" href="#Пример-от-Артема-К-1">Пример от Артема К</a></h3>
<pre><code class="language-cpp">int (* (** (* (* x)[5])(void))[10])();
</code></pre>
<p>x - это указатель на массив размера 5 из указателей на функции, принимающие void (то есть не принимающие аргументов - это альтернативный синтаксис) и отдающие указатель на указатель на массив размера 10 из указателей на функции без аргументов, возвращающие int</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Категории-значений-move-семантика"><a class="header" href="#Категории-значений-move-семантика">Категории значений, move-семантика</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reference-collapsing-rule"><a class="header" href="#reference-collapsing-rule">Reference collapsing rule</a></h2>
<p>Еще до С++11 ввели правило, что ссылка на ссылку - это ссылка без вложенности. В связи с введением <code>rvalue</code>-ссылок правило пришлось дополнить.</p>
<pre><code>(A&amp;)&amp; -&gt; A&amp;
(A&amp;)&amp;&amp; -&gt; A&amp;
(A&amp;&amp;)&amp; -&gt; A&amp;
(A&amp;&amp;)&amp;&amp; -&gt; A&amp;&amp;
</code></pre>
<p>Так же в связи с появлением нового типа ссылок стало необходимо распознавать, ссылка какого типа пришла в функцию. Разработчики решили даром синтаксис не терять и не городить новых конструкций, поэтому написание <code>T&amp;&amp;</code> от шаблонного типа стало означать новую фичу.</p>
<p>Важный момент! Помните, что</p>
<pre><code class="language-cpp">int a = 42;

int&amp; b = a; // lvalue-ссылка, имеющая lvalue категорию
const int&amp; b = a; // то же самое

int&amp;&amp; f() {
    return 42;
}

f(); // rvalue-ссылка, имеющая xvalue категорию
int&amp;&amp; b = std::move(a); // rvalue-ссылка, имеющая lvalue категорию

int g(int&amp;&amp; a) { // a - rvalue-ссылка, имеющая lvalue категорию
    return a;
}
</code></pre>
<h2 id="Универсальная-ссылка"><a class="header" href="#Универсальная-ссылка">Универсальная ссылка</a></h2>
<p>В C++11 правила вывода шаблонных параметров были определены специальным образом, который позволил сохранять информацию о том, ссылка какого типа в функцию передавалась.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(a);
}

int main() {
    g(42); // rvalue: T -&gt; int, void g(int&amp;&amp;)
    int a;
    g(a); // lvalue: T -&gt; int&amp;, void g(int&amp;)
}
</code></pre>
<p>Шаблонная &quot;<code>rvalue</code>&quot;-ссылка ведет себя по-разному в зависимости от того, что в нее передали - она становится либо <code>lvalue</code>-ссылкой, либо <code>rvalue</code>-ссылкой.</p>
<p>Реализуется компилятором это тривиально: создаются обе версии, если нужно.</p>
<p>На примере выше можно передавать в <code>g(T&amp;&amp;)</code> любой тип, и он прикастуется к ссылке определенного типа. Но есть подвох: как ни крути тип ссылки в рантайме мы все-таки не знаем, а в вызовах <code>f(A&amp;&amp;)</code> из <code>g(T&amp;&amp;)</code> вообще будет присутствовать только версия, принимающая <code>lvalue</code>-ссылку.</p>
<p>Почему? Так как <code>T&amp;&amp; a</code> - именованная ссылка, значит она имеет категорию <code>lvalue</code>, значит тип аргумента будет (T&amp;&amp;)&amp; -&gt; T&amp;, либо (T&amp;)&amp; -&gt; T&amp; по правилу схлопывания ссылок. Для того, чтобы сохранять информацию о типе ссылки на уровне компиляции, придумали <code>std::forward</code>.</p>
<h2 id="stdforward"><a class="header" href="#stdforward">std::forward</a></h2>
<p>Использование <code>Perfect forwarding</code> позволяет сохранять тип ссылки на уровне компиляции.</p>
<pre><code class="language-cpp">
void bar(int&amp; v) {
    std::cout &lt;&lt; &quot;lvalue&quot;;
}

void bar(int&amp;&amp; v) {
    std::cout &lt;&lt; &quot;rvalue&quot;;
}

template &lt;typename T&gt;
void foo(T&amp;&amp; v) {
    bar(v);
}

template &lt;typename T&gt;
void foo2(T&amp;&amp; v) {
    bar(std::forward&lt;T&gt;(v));
}

int a = 42;
foo(a);  // out: lvalue
foo(42); // out: lvalue

foo2(a);  // out: lvalue
foo2(42); // out: rvalue

</code></pre>
<p>Часто <code>std::forward</code> применяется вместе с variadic templates.</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    g(std::forward&lt;Args&gt;(args)...);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Наследование-virtual-приведение-типов"><a class="header" href="#Наследование-virtual-приведение-типов">Наследование, virtual, приведение типов</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Объявление-шаблона"><a class="header" href="#Объявление-шаблона">Объявление шаблона</a></h2>
<p>Объявление шаблонного класса или шаблонной функции в примере ниже:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct vector {
    void push_back(T const &amp;);
    T const&amp; operator[](size_t index) const;
    
    template &lt;typename U&gt;
    void g(T, U);
};

template &lt;typename T&gt;
void f(T&amp;&amp; a, T&amp;&amp; b) {
    std::cout &lt;&lt; a + b &lt;&lt; std::endl;
}
</code></pre>
<p>Вместо T и U будет подставляться тот тип, который был указан в шаблонном параметре при использовании класса/функции. Также в большинстве случаев компилятор может вывести тип самостоятельно без явного его указания.</p>
<pre><code class="language-cpp">vector&lt;int&gt; v;
vector&lt;double&gt; v2;

v.template g&lt;float&gt;(42, 42.0);
v.g(42, 42.0); // same

f(1, 3);     // 4
f(1.5, 2.5); // 4.0
</code></pre>
<h2 id="Специализации"><a class="header" href="#Специализации">Специализации</a></h2>
<p>Специализация - это выделенная реализация для каких-то указанных типов. К примеру из примера выше для <code>vector&lt;std::string&gt;</code> и <code>void f(bool&amp;&amp;, bool&amp;&amp;)</code> я бы хотел иметь другое тело функции. Это пример надуманный, конечно.</p>
<pre><code class="language-cpp">template &lt;&gt;
struct vector&lt;std::string&gt; {
    /* ... */
};

template &lt;&gt;
void f&lt;bool&gt;(bool&amp;&amp; a, bool&amp;&amp; b) {
    std::cout &lt;&lt; (a | b) &lt;&lt; std::endl;
}
</code></pre>
<p>Специализацию можно вводить не целиком, а частично, оставляя свободными другие шаблонные параметры. В качестве примера рассмотрим простенькую реализацию <code>std::conditional</code>.</p>
<pre><code class="language-cpp">template &lt;bool Cond, typename IfTrue, typename IfFalse&gt;
struct conditional;

template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;false, IfTrue1, IfFalse1&gt; { // partial specialization
    typedef IfFalse1 type;
};

template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;true, IfTrue1, IfFalse1&gt; { // partial specialization
    typedef IfTrue1 type;
};
</code></pre>
<p>Специализациям свойственен большее высокий приоритет при разрешениях перегрузок (overload resolution).</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct vector&lt;T*&gt; {
    /* ... */
}

vector&lt;foo*&gt; v; // выберется эта специализация
</code></pre>
<p>Пример неразрешимой перегрузки:</p>
<pre><code class="language-cpp">template &lt;typename U, typename V&gt;
struct mytype {};

template &lt;typename U, typename V&gt;
struct mytype&lt;U*, V&gt; {};

template &lt;typename U, typename V&gt;
struct mytype&lt;U, V*&gt; {};

mytype&lt;long*, double*&gt; f;
</code></pre>
<p>Мы получим ошибку, так как есть два равноправных кандидата. Исправить это можно определением еще одной, более подходящей специализации:</p>
<pre><code class="language-cpp">template &lt;typename U, typename V&gt;
struct mytype&lt;U*, V*&gt; {};
</code></pre>
<h2 id="Ошибка-разделения-на-объявление-и-реализацию"><a class="header" href="#Ошибка-разделения-на-объявление-и-реализацию">Ошибка разделения на объявление и реализацию</a></h2>
<p>Давайте представим, как мы могли бы писать код с шаблонными функциями, используя разделение на объявление и реализацию, как полагается.</p>
<pre><code class="language-cpp">// util.h
template &lt;typename T&gt;
void f(T&amp;, T&amp;);

// util.cpp
template &lt;typename T&gt;
void f(T&amp; a, T&amp; b) {
    std::cout &lt;&lt; a + b &lt;&lt; std::endl;
}

// main.cpp
#include &quot;util.h&quot;
int main(){
    int a, b;
    f(a, b);
}
</code></pre>
<p>Но в данном примере, к сожалению, мы получим ошибку компиляции. Так происходит, потому что генерация и подстановка кода шаблонов (инстанцирование) происходит до линковки и после компиляции каждой отдельной единицы трансляции. Компилятор, обрабатывая <code>util.cpp</code>, не знает о том, что кто-то будет вызывать <code>f(int, int)</code> в других единицах трансляции.</p>
<p>На самом деле все шаблонные функции неявно являются <code>inline</code>, поэтому их реализацию можно сразу писать в <code>.h</code> файле.</p>
<h2 id="Инстанцирование"><a class="header" href="#Инстанцирование">Инстанцирование</a></h2>
<p>В стандарте прописано, что инстанцирование происходит только когда это необходимо. При этом компилятор может делать это в конце единицы трансляции.</p>
<p>В следующем примере приводится случай, который это показывает:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct foo {
    T* a;
    void f(){
        T a;
    }
};

int main() {
    foo&lt;void&gt; a; // так скомпилируется
    a.f();       // а так нет, ошибка из-за void a
}
</code></pre>
<p>Генерация и подстановка по требованию, так сказать. С классами работает аналогично: полное тело класса не подставляется, если не требуется. Пример:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct foo {
    T a;
};

int main() {
    foo&lt;void&gt;* a; // так скомпилируется
    a-&gt;a;         // а так нет, опять ошибка из-за void a
}
</code></pre>
<h2 id="Явное-инстанцирование"><a class="header" href="#Явное-инстанцирование">Явное инстанцирование</a></h2>
<p>Пусть мы не хотим, чтобы одни и те же лишние инстанцирования были в разных единицах трансляции. Чтобы этого избежать, можно делать так:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void foo(T) {}

template void foo&lt;int&gt;(int); // генерирует тело функции в этом месте
template void foo&lt;float&gt;(float);
template void foo&lt;double&gt;(double);
</code></pre>
<h2 id="Подавление-инстанцирования"><a class="header" href="#Подавление-инстанцирования">Подавление инстанцирования</a></h2>
<p>Пусть мы знаем, что функции уже где-то инстанцированы и мы не хотим лишних:</p>
<pre><code class="language-cpp">extern template void foo&lt;int&gt;(int); 
extern template void foo&lt;float&gt;(float);
</code></pre>
<p>Выдаём тело наружу и говорим, что уже проинстанцировано. <code>main</code> не будет пытаться инстанцировать функцию, так как увидит <code>extern</code> и будет работать соответствующе.</p>
<p>Теперь зная про шаблоны и специализации можно творить всякую магию:</p>
<h2 id="Подсчет-факториала-в-compile-time"><a class="header" href="#Подсчет-факториала-в-compile-time">Подсчет факториала в compile-time</a></h2>
<p>Осторожно, при отрицательных значениях компилятор может надолго зависнуть.</p>
<pre><code class="language-cpp">template &lt;int T&gt;
struct factorial {
    static const int result = T * factorial&lt;T - 1&gt;::result;
};


template &lt;&gt;
struct factorial&lt;0&gt; {
    static const int result = 1;
};

static_assert(factorial&lt;0&gt;::result == 1);
static_assert(factorial&lt;3&gt;::result == 6);
static_assert(factorial&lt;5&gt;::result == 120);
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/11_templates.md">cpp-notes/11_templates.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parameter-pack"><a class="header" href="#parameter-pack">Parameter pack</a></h2>
<p>В следующую функцию можно передать ноль или более различных аргументов любого типа.</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    // ...
}
</code></pre>
<p>Как теперь можно работать с аргументом <code>args</code>?</p>
<p>Можно развернуть его в список аргументов другой функции, как если бы мы перечислили аргументы через запятую.</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    std::cout &lt;&lt; sum(args...);
}
</code></pre>
<p>Теперь если мы вызовем <code>f(1, 1.f, '1')</code>, то в консоль выведется результат <code>sum(1, 1.f, '1')</code>.</p>
<p>Parameter pack можно использовать и для более хитрых вещей, например, в следующем примере:</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    std::cout &lt;&lt; sum((args * 2)...);
}
</code></pre>
<p>Конструкция <code>((args * 2)...)</code> развернется в <code>(a1 * 2, a2 * 2, a3 * 2)</code>.</p>
<p>Раскрывать parameter pack можно с помощью, например, рекурсии:</p>
<pre><code class="language-cpp">int sum(int t) {
    return t;
}

template &lt;typename... Tail&gt;
int sum(int t, Tail... tail) {
    return t + sum(tail...);
}

template&lt;typename... Args&gt;
void f(Args... args) {
    std::cout &lt;&lt; sum(args...);
}

f(1, 2, 3); // out: 6
</code></pre>
<p>С помощью variadic templates, <code>type_traits</code> и <code>SFINAE</code> можно делать умопомрачительные вещи (в том числе в compile-time), но мы опустим этот момент.</p>
<h2 id="fold-expressions-c17"><a class="header" href="#fold-expressions-c17">Fold expressions (C++17)</a></h2>
<p>Синтаксис:</p>
<ol>
<li>( pack_name op ... )</li>
<li>( ... op pack_name )</li>
<li>( pack_name op ... op init )</li>
<li>(init op ... op pack )</li>
</ol>
<p>где pack_name - имя parameter pack, op - оператор, init - начальное значение.</p>
<p>Во что эти конструкции разворачиваются:</p>
<ol>
<li>( E op ... ) -&gt; ( E1 op (... op ( En-1 op En )))</li>
<li>( ... op E) -&gt; ((( E1 op E2 ) op ...) op En )</li>
<li>( E op ... op I ) -&gt; ( E1 op (... op ( En op I )))</li>
<li>( I op ... op E ) -&gt; ((( I op E1 ) op ...) op En )</li>
</ol>
<h3 id="Битовое-И-переменного-числа-аргументов"><a class="header" href="#Битовое-И-переменного-числа-аргументов">Битовое И переменного числа аргументов</a></h3>
<pre><code class="language-cpp">template &lt;typename... Args&gt;
bool all(Args... args) {
    return (... &amp;&amp; args);
}

static_assert(all(true, true, false) == false);
static_assert(all() == true); // ?
</code></pre>
<p>Для раскрытия parameter pack длины 0 некоторые операторы имеют значения по умолчанию:</p>
<ul>
<li>Логическое И -&gt; <code>true</code></li>
<li>Логическое ИЛИ -&gt; <code>false</code></li>
<li>Оператор запятой <code>,</code> -&gt; <code>void()</code> (?)</li>
</ul>
<h3 id="Вывод-в-консоль-переменного-числа-аргументов"><a class="header" href="#Вывод-в-консоль-переменного-числа-аргументов">Вывод в консоль переменного числа аргументов</a></h3>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void print(Args&amp;&amp;... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; '\n';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Исключения-noexcept"><a class="header" href="#Исключения-noexcept">Исключения, noexcept</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constexpr-consteval-if"><a class="header" href="#constexpr-consteval-if">constexpr, consteval, if</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decltype-declval-auto"><a class="header" href="#decltype-declval-auto">decltype, declval, auto</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sfinae"><a class="header" href="#sfinae">SFINAE</a></h2>
<p>SFINAE - substitution failed is not an error. Для того, чтобы сказать, что это такое, необходимо вспомнить, как разрешаются перегрузки функций.</p>
<pre><code class="language-cpp">void f(int, std::vector&lt;int&gt;);
void f(int, int);
void f(double, double);
void f(int, int, char, std::string, std::vector&lt;int&gt;);
void f(std::string);

f(1, 2);
</code></pre>
<ol>
<li>Для сопоставления <code>f(1, 2)</code> с конкретной функцией компилятор отправит все функции с названием <code>f</code> в overload resolution.</li>
<li>Далее из списка исчезают кандидаты, у которых количество параметров не может совпасть с теми, что представлены в вызове.</li>
<li>Потом отсекаются функции, типы параметров которых отличаются от переданных аргументов и для которых нет неявного преобразования.</li>
<li>После этого идут несложные, но многословные правила поиска лучшей перегрузки, и побеждает <code>f(int, int)</code>, так как она не требует преобразований аргументов.</li>
</ol>
<p>Если бы обе подходили одинаково хорошо, то вызов был бы двусмысленным, о чём компилятор сообщил бы. Так, в общих чертах, и работает перегрузка методов в C++.</p>
<h3 id="Добавим-шаблонные-функции"><a class="header" href="#Добавим-шаблонные-функции">Добавим шаблонные функции!</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
void function(T, T);
</code></pre>
<p>Теперь несколько изменится первая стадия:</p>
<p>Если компилятор встречает шаблонную функцию, имя которой совпадает с именем вызова, тогда он пытается вывести <em>аргументы шаблона</em>, на основании аргументов переданных в вызов (<code>argument deduction</code>).</p>
<p>И если все аргументы удаётся вывести, то шаблонная функция с выведенными аргументами добавляется в список кандидатов функций.</p>
<p>В нашем примере в конце все равно останется только нешаблонная <code>f(int, int)</code>, так как при прочих равных нешаблонная функция всегда сильнее шаблонной.</p>
<p>А что происходит, если вывести аргументы шаблона не удалось? Тогда такая шаблонная функция просто не попадает в список overload resolution. Это и есть правило <code>SFINAE</code>. Но следует понимать, что рассматривается <strong>исключительно</strong> сигнатура функции и ничего больше.</p>
<p>Поэтому если подстановка аргументов даёт корректную функцию с точки зрения её сигнатуры, и функция побеждает в перегрузке, а потом оказывается, что в теле функции есть какие-то проблемы, с которыми компилятор справится не может, то компиляция будет завершена ошибкой - это называется <code>hard error</code>.</p>
<h2 id="Примитивное-sfinae"><a class="header" href="#Примитивное-sfinae">Примитивное SFINAE</a></h2>
<p>Используя SFINAE мы можем получить рефлексию на этапе компиляции, узнавая свойства объектов, и в зависимости от этого разрешать или запрещать им использовать какие-то функции и прочее.</p>
<p>Следующая шаблонная шапка позволяет использовать функцию после нее только с типами, в которых объявлен тип с алиасом <code>iterator</code>. Если такого алиаса в типе объявлено не будет, то произойдет ошибка вывода шаблонных аргументов и данная функция не попадет в список overload resolution.</p>
<pre><code class="language-cpp">template &lt;typename T, typename = typename T::iterator&gt;
</code></pre>
<p>Подобным образом в шаблонных параметрах можно объявлять и другие ограничения на используемые шаблонные типы.</p>
<h2 id="О-сигнатуре-шаблонной-функции"><a class="header" href="#О-сигнатуре-шаблонной-функции">О сигнатуре шаблонной функции</a></h2>
<p>Многим известно, что возвращаемый тип в функции не является частью её сигнатуры, но это не так для шаблонных функций. Это позволяет использовать, например, <code>std::enable_if</code> на возвращаемом типе.</p>
<p>Схематично, это выглядит так:</p>
<pre><code class="language-cpp">template &lt;bool condition, class T = void&gt;
struct enable_if;

template&lt;class T&gt;
struct enable_if&lt;true, T&gt; {
    typedef T type;
};
</code></pre>
<p>То есть, при передаче в шаблон <code>true</code> в структуре появляется поле <code>type</code> по умолчанию типа <code>void</code>, но если шаблон был вызван с параметром <code>false</code>, то этого поля не будет, а его использование в сигнатуре функции или в шапке шаблона приведет к неудаче вывода, и эта перегрузка не будет включена в список кандидатов.</p>
<p>Напишем надуманный пример, использующий <code>enable_if</code> в возвращаемом типе.</p>
<pre><code class="language-cpp">namespace {
    struct tag;
}

template &lt;typename T&gt;
enable_if&lt;std::is_trivially_destructible_v&lt;T&gt;&gt;::type f(T);

template &lt;typename T&gt;
enable_if&lt;!std::is_trivially_destructible_v&lt;T&gt;, tag&gt;::type f(T);

template &lt;typename T&gt;
constexpr bool is_void_f = std::is_same_v&lt;decltype(f(std::declval&lt;T&gt;())), void&gt;;

int main() {
    std::cout &lt;&lt; is_void_f&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_void_f&lt;std::string&gt; &lt;&lt; std::endl;
} // output: 1 0
</code></pre>
<h2 id="Применение-sfinae-в-бою"><a class="header" href="#Применение-sfinae-в-бою">Применение SFINAE в бою</a></h2>
<p>В заметке про <code>if constexpr</code> написан пример, позволяющий по члену класса <code>has_foo</code> судить о наличии соответствующего метода в классе. Попробуем написать метафункцию, определяющую существование в классе, например, метода <code>void foo(int)</code> с помощью новых знаний.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
    static constexpr bool value = true; // сейчас придумаем, что здесь написать
};
</code></pre>
<p>Осталось придумать перегрузку, определяющие нужные нам свойства типа, и как получить из нее булевскую константу.</p>
<p>Во-первых создадим всеядную функцию-подложку (иногда говорят, fallback), которую компилятор выберет, если не подойдет полезная перегрузка, присваивающая каким-то образом в <code>value</code> значение <code>true</code>.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
    struct dummy;
    static dummy detect(...); // fallback
    static constexpr bool value = true;  // ладно-ладно, уже скоро придумаем!
};
</code></pre>
<p>Теперь придумаем детектор. Здесь нам придется воспользоваться конструкциями <code>decltype</code> и <code>std::declval</code>, которые могут вызываться на этапе компиляции и проверять свойства без реальных вызовов конструкторов, функций и прочего.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
    struct dummy;
    static dummy detect(...); // fallback
    
    template&lt;typename U&gt;
    static decltype(std::declval&lt;U&gt;().foo(42)) detect(const U&amp;); // detector
    
    static constexpr bool value = true;  // теперь точно скоро!
};
</code></pre>
<p>Теперь осталось воспользоваться детектором, чтобы поставить правильное значение поля <code>value</code>. Также упростим синтаксис для конечного пользователя.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
private:  // скроем детали реализации
    struct dummy;
    static dummy detect(...);
    
    template&lt;typename U&gt;
    static decltype(std::declval&lt;U&gt;().foo(42)) detect(const U&amp;);
    
public:
    static constexpr bool value =
        std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value;
};

template &lt;typename T&gt;
constexpr bool has_foo_v = has_foo&lt;T&gt;::value;
</code></pre>
<p>Использование:</p>
<pre><code class="language-cpp">struct check1 {
    void foo(int);
};

struct check2 {};

int main() {
    std::cout &lt;&lt; has_foo_v&lt;check1&gt; &lt;&lt; std::endl; // 1
    std::cout &lt;&lt; has_foo_v&lt;check2&gt; &lt;&lt; std::endl; // 0
    // или
    std::cout &lt;&lt; has_foo&lt;check1&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; has_foo&lt;check2&gt;::value &lt;&lt; std::endl;
}
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="http://scrutator.me/post/2016/12/12/sfinae.aspx">SFINAE. Как много в этом слове (scrutator.me)</a></p>
<p><a href="https://habr.com/ru/post/205772/">SFINAE — это просто / Хабр (habr.com)</a></p>
<p><a href="https://ru.wikipedia.org/wiki/SFINAE">SFINAE — Википедия (wikipedia.org)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raii-умные-указатели"><a class="header" href="#raii-умные-указатели">RAII, умные указатели</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ebo-rvo-pgo-lto"><a class="header" href="#ebo-rvo-pgo-lto">EBO, RVO, PGO, LTO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Лямбда-функция"><a class="header" href="#Лямбда-функция">Лямбда-функция</a></h2>
<p>Имеет следующий синтаксис:</p>
<pre><code class="language-cpp">auto lambda = [](int a, int b) {return a &lt; b;}
</code></pre>
<p>Полученный объект по сути является структурой с известным только компилятору уникальным типом, имеющим <code>operator()</code> с аргументами, которые передаются в лямбду.</p>
<p>Возвращаемый тип можно задать явно через trailing return types, либо довериться компилятору (равносильно типу auto).</p>
<p>Квадратные скобки здесь не просто для красоты - они используются для захвата переменных из контекста объявления лямбда-функции:</p>
<pre><code class="language-cpp">int a = 42;

// захват переменной по значению
auto mul = [a](int k) {return k * a;}

// захват переменной по ссылке
auto add = [&amp;a](int k) {return k + a;}

// захват переменной по значению с присвоением нового имени (C++14)
auto sub = [b = a](int k) {return k - b;}

// захват переменной по ссылке с присвоением нового имени (C++14)
auto div = [&amp;b = a](int k) {return k / b;}
</code></pre>
<p>Также лямбды умеют делать захват всего контекста по значению или ссылке:</p>
<pre><code class="language-cpp">int x, y;

[=](){}    // все по значению
[=, &amp;x](){} // все по значению, x - по ссылке

[&amp;](){}    // все по ссылке
[&amp;, x](){} // все по ссылке, x - по значению
</code></pre>
<p>Захваченные по значению объекты являются константными, если лямбда-функция не имеет спецификатора <code>mutable</code>. Также можно захватывать <code>this</code>, как указатель на объект, где лямбда была объявлена, а можно захватывать <code>*this</code>, как копию объекта.</p>
<h3 id="Свойства-лямбд"><a class="header" href="#Свойства-лямбд">Свойства лямбд</a></h3>
<ul>
<li>могут копироваться и перемещаться</li>
<li>не могут присваиваться</li>
<li>лямбды без захвата могут конвертиться к указателю на функцию</li>
<li>при копировании лямбды копируются все захваченные по значению переменные</li>
<li>захват по ссылке не продлевает время жизни объектов. Такой код работает неправильно:</li>
</ul>
<pre><code class="language-cpp">auto foo() {
    std::vector&lt;int&gt; v;
    return [&amp;v]() {
        // ...
    };
} // v уничтожится при выходе из функции, обращение внутри лямбды - UB
</code></pre>
<p>Начиная с C++20 лямбды могут иметь шаблонные параметры:</p>
<pre><code class="language-cpp">int main() {
    auto less = []&lt;typename T&gt;(T a, T b) {return a &lt; b;};
    bool val = less(42, 43);
}
</code></pre>
<h3 id="Рекурсивный-вызов-лямбды"><a class="header" href="#Рекурсивный-вызов-лямбды">Рекурсивный вызов лямбды</a></h3>
<p>Пример ниже выдаст ошибку компиляции:</p>
<pre><code class="language-cpp">auto factorial = [&amp;factorial](int n) {
    return n &lt;= 1 ? 1 : n * factorial(n - 1);
};

</code></pre>
<p><code>error: use of 'factorial' before deduction of 'auto'</code>, что говорит нам о том, что тип <code>auto</code> еще не был выведен, поэтому пользоваться им нельзя.</p>
<h4 id="Вариант-1"><a class="header" href="#Вариант-1">Вариант 1</a></h4>
<pre><code class="language-cpp">std::function&lt;int(int)&gt; factorial;

factorial = [&amp;](int n) {
    return n &lt;= 1 ? 1 : n * factorial(n - 1);
};

std::cout &lt;&lt; factorial(4);
</code></pre>
<h4 id="Вариант-2"><a class="header" href="#Вариант-2">Вариант 2</a></h4>
<pre><code class="language-cpp">auto factorial = [](int n, auto&amp;&amp; f) -&gt; int {
    return (n &lt;= 1 ? 1 : n * f(n - 1, f));
};

std::cout &lt;&lt; factorial(4, factorial);
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/19_lambdas_type_erasure.md">cpp-notes/19_lambdas_type_erasure.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdfunction"><a class="header" href="#stdfunction">std::function</a></h2>
<p>Пусть <code>void(int,int)</code> - это тип функции, принимающей два инта и возвращающей ничего, тогда мы можем похранить ее в <code>std::function</code> следующим образом.</p>
<pre><code class="language-cpp">void print(int a, int b) {
    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
}

std::function&lt;void(int, int)&gt; func = print;

func(1, 2); // output: 1 2
</code></pre>
<p>Похранить функции с другой сигнатурой мы тоже, конечно, можем.</p>
<p>С помощью <code>function</code> мы так же можем хранить и лямбды (и любой другой функциональный объект).</p>
<pre><code class="language-cpp">void f(bool flag) {
    std::function&lt;void(int,int)&gt; func;
    if (flag) {
        func = [](int a, int b){}; 
    } else {
        // note: все лямбды имеют разный тип
        func = [](int a, int b){};
    }
}
</code></pre>
<p>Примечательно, что классу <code>function</code> достаточно знать только тип функции и только на этапе объявления объекта.</p>
<p>Этот класс реализует паттерн <code>type erasure</code>. Тот же самый паттерн встречается и в других классах STL.</p>
<h2 id="stdoptional"><a class="header" href="#stdoptional">std::optional</a></h2>
<p>Класс, который хранит опциональное значение (либо шаблонный тип, либо <code>std::nullopt_t</code>).</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; convert(std::function&lt;void(int)&gt; &amp;f) {
    // ....
    if (!fail) {
        return result;
    }
    return {};
}

int main() {
    auto val = convert(...);
    if (val.has_value()) {
        std::cout &lt;&lt; &quot;OK&quot;;
    } else {
        std::cout &lt;&lt; &quot;Fail&quot;;
    }
}
</code></pre>
<h2 id="stdany"><a class="header" href="#stdany">std::any</a></h2>
<p>Тип <code>any</code> хранит в себе объект любого типа. Так одна и та же переменная типа <code>any</code> может сначала хранить <code>int</code>, затем <code>float</code>, а затем строку.</p>
<p>Требуется каст для обратного преобразования.</p>
<pre><code class="language-cpp">std::any a = 42;
int v = std::any_cast&lt;int&amp;&gt;(a);

a = std::string(&quot;hello&quot;);
std::string s = std::any_cast&lt;std::string&amp;&gt;(a);

// a = mytype(); и так далее
</code></pre>
<p>Если в качестве шаблонного параметра <code>any_cast</code> был передан любой тип, отличный от типа текущего хранимого объекта, будет выброшено исключение <code>bad_any_cast</code>.</p>
<p>Если экземпляр <code>any</code> разрушается деструктором, то он корректно удаляет хранимый объект.</p>
<h2 id="stdvariant"><a class="header" href="#stdvariant">std::variant</a></h2>
<p>Шаблонный класс, который представляет собой типобезопасный <code>union</code>, который помнит, какой тип он хранит. В отличие от <code>union</code> , <code>variant</code> позволяет хранить не только POD-типы (тривиальные типы или тривиальные классы).</p>
<pre><code class="language-cpp">std::variant&lt;int, float, char&gt; v;

v = 3.14f;
v = 42;

std::cout &lt;&lt; std::get&lt;int&gt;(v);
</code></pre>
<p>Для получения значений из <code>variant</code> используется функция <code>get</code>. Она выбросит исключение <code>bad_variant_access</code>, если попытаться взять не тот тип.</p>
<p>Говоря про доступ к варианту, нельзя не упомянуть <code>visit</code>, принимающий функцию, которая должна уметь принимать любой тип из данного <code>variant</code>.</p>
<pre><code class="language-cpp">std::variant&lt;int, float, char&gt; v;
v = 42;

std::visit([](auto&amp; arg) {
    using Type = std::decay_t&lt;decltype(arg)&gt;;

    if constexpr (std::is_same_v&lt;Type, int&gt;) {
        std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; arg;

    } else if constexpr (std::is_same_v&lt;Type, float&gt;) {
        std::cout &lt;&lt; &quot;float: &quot; &lt;&lt; arg;

    } else if constexpr (std::is_same_v&lt;Type, char&gt;) {
        std::cout &lt;&lt; &quot;char: &quot; &lt;&lt; arg;
    }
}, v);
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/19_lambdas_type_erasure.md">cpp-notes/19_lambdas_type_erasure.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h2>
<p>Если поток не завершил работу, не вызваны методы <code>join()</code> или <code>detach()</code>, но его деструктор <code>thread</code> уже запущен, то программа аварийно завершится вызовом <code>std::terminate</code>.</p>
<p>После успешного вызова на потоке методов <code>join()</code> или <code>detach()</code> метод <code>joinable()</code> будет возвращать ложь.</p>
<p>Вызов метода <code>join()</code> на одном и том же объекте <code>thread</code> из разных потоков - это undefined behavior, в том числе потому что нельзя делать <code>join()</code> потоку, который возвращает <code>joinable()</code> == <code>false</code>. Это приводит к генерации исключения.</p>
<p>Если вам действительно нужно дождаться выполнения потока из разных потоков, то можно это делать более чистыми способами.</p>
<p>Что случится с <code>detached</code>-потоками, когда программа выйдет из main?</p>
<p>Их исполнение будет приостановлено ОС, память освобождена (но не через деструкторы, а просто). Необходимо сделить за тем, что происходит в отсоединенных потоках, чтобы после завершения программы файлы не оставались полузаписанными и shared-память не становилась поломанной. Ресурсы наподобие блокировок на файл будут освобождены самой ОС.</p>
<h2 id="stdconditional_variable"><a class="header" href="#stdconditional_variable">std::conditional_variable</a></h2>
<p>Важно знать, что <code>conditional_variable</code> иногда может просыпаться и без вызова <code>.notify_one()</code>, поэтому более безопасный код будет выглядеть так:</p>
<pre><code class="language-cpp">bool signaled = false;

// start background threads...
// someone will set signaled as true, then call cv.notify_one()

{
    std::unique_lock&lt;std::mutex&gt; lock(mutex);
    while (!signaled) {
        cv.wait(lock);
    }
    signaled = false;
}
</code></pre>
<h2 id="false-sharing"><a class="header" href="#false-sharing">False-sharing</a></h2>
<p>Существует два типа разделения кэш-линий: true sharing и false sharing.</p>
<p>True sharing - это когда потоки имеют доступ к одному и тому же объекту памяти, например, общей переменной или примитиву синхронизации.</p>
<p>False sharing - это доступ к разным данным, но по каким-то причинам оказавшимся в одной кэш-линии процессора.</p>
<p>И тот, и другой случай вредит производительности из-за необходимости аппаратной синхронизации кэш-памяти процессора, однако если первый случай часто неизбежен, то второй можно и нужно исключать.</p>
<p>В случае постоянной модификации данных в условиях false sharing, процессору в соответствии с протоколом когерентности кэша необходимо инвалидировать эту кэш-линию целиком для остальных ядер процессора.</p>
<p>Другой поток уже не сможет пользоваться своими данными, несмотря на то, что они уже лежат в L1 кэше его ядра. Вследствие этого между ядрами происходит синхронизация памяти. Данная операция дорого обходится, если потоки выполняют что-то в цикле - производительность может падать в разы.</p>
<p>На архитектуре x86 в кэш-линию может помещаться 64 байта данных, поэтому если работа происходит с массивом структур данных в многопоточке, то нужно позаботиться о следующих вещах:</p>
<ol>
<li>Выравнивание массива</li>
<li>Наличие подкладки до 64 байт (<code>padding</code>)</li>
</ol>
<hr />
<p>Заимствования:</p>
<p><a href="https://stackoverflow.com/questions/22803600/when-should-i-use-stdthreaddetach">c++ - When should I use std::thread::detach? - Stack Overflow</a></p>
<p><a href="https://habr.com/ru/company/intel/blog/143446/">Делиться не всегда полезно: оптимизируем работу с кэш-памятью / Хабр (habr.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdatomic-memory_order"><a class="header" href="#stdatomic-memory_order">std::atomic, memory_order</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Квалификатор-volatile"><a class="header" href="#Квалификатор-volatile">Квалификатор volatile</a></h2>
<p>Квалификатор <code>volatile</code> говорит компилятору, что оптимизировать данную переменную запрещено, и что компилятор никогда не сможет предвидеть или вычислить ее значение заранее.</p>
<pre><code class="language-cpp">volatile int flag = 42;
</code></pre>
<p>Когда это вообще нужно? Рассмотрим следующий пример:</p>
<pre><code class="language-cpp">bool cancel = false;
/* ... */

while (!cancel) {
    /* ... */
}
</code></pre>
<p>Если в теле цикла переменная <code>cancel</code> не меняется, то компилятор может соптимизировать ее проверку, и в цикл мы не войдем никогда.</p>
<p>Таким и должно быть наблюдаемое поведение, если мы не пишем сложной логики, например, если переменная <code>cancel</code> не шарится с другими потоками или процессами, которые могут ее перезаписывать. Использование <code>volatile</code> нужно для предупреждения компилятора, что <em>магические силы</em> могут изменить значение переменной в любой момент и нельзя опираться на то, что в нее было записано в compile-time.</p>
<p>Другой пример:</p>
<pre><code class="language-cpp">unsigned char* pControl = 0xff24;

void f() {
    *pControl = 1;
    *pControl = 0;
    *pControl = 0;
}
</code></pre>
<p>Компилятор может опустить первые две операции присваивания, оставив только последнюю. Когда это может быть вредно? При разработке программ, работающих с <code>Memory mapped IO</code>, то есть взаимодействующих с какими-то железками через оперативную память, или при разработке драйверов, где важно каждое переданное значение.</p>
<p>Использование <code>volatile</code> запрещает перегруппировку инструкций доступа и их оптимизацию, но ни в коем случае не гарантирует атомарности. Чтение <code>volatile</code> переменной при одновременной записи в нее из другого потока или одновременная запись из разных потоков без синхронизации - это data race.</p>
<p>Также использование <code>volatile</code> запрещает использование переменной из регистра - каждое чтение будет связано с загрузкой из оперативной памяти. Это свойство кажется уже очевидным, но тем не менее стоит подчеркнуть, что такое поведение можно использовать для каких-нибудь бенчмарков.</p>
<p>Разумеется, нельзя использовать волатильную переменную со снятым позднее через <code>const_cast</code> квалификатором <code>volatile</code> - это undefined behavior.</p>
<hr />
<p>Заимствования:</p>
<p><a href="https://en.cppreference.com/w/c/language/volatile">volatile type qualifier - cppreference.com</a></p>
<p><a href="http://alenacpp.blogspot.com/2006/04/volatile.html">Алёна C++: Ключевое слово volatile (alenacpp.blogspot.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdpromise-stdfuture-stdasync"><a class="header" href="#stdpromise-stdfuture-stdasync">std::promise, std::future, std::async</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Корутины"><a class="header" href="#Корутины">Корутины</a></h1>
<p>Корутины - это потоки исполнения кода, которые организуются поверх аппаратных (системных) потоков и работают на более высоком уровне - несколько корутин могут по очереди выполнять свой код на одном системном потоке (в зависимости от реализации, корутины могут быть не привязаны к конкретному системному потоку, а например выполнять свой код на пуле потоков).</p>
<p>В отличие от системных потоков, которые переключаются системой в произвольные моменты времени (вытесняющая многозадачность), корутины переключаются вручную в местах, указанных программистом (кооперативная многозадачность).</p>
<p>Простыми словами: корутина может остановиться и передать управление другому потоку (другой корутине), а потом вернуться к текущей инструкции и продолжить выполнение до либо очередной паузы и передачи потока выполнения, либо завершения работы.</p>
<p>В C++20 есть три механизма для работы с корутинами:</p>
<p><code>co_await</code> - ожидание асинхронного результата
<code>co_yield</code> - приостанавливает работу корутины и возвращает какое-то значение
<code>co_return</code> - возвращает значение и завершает работу корутины</p>
<p>Функция является корутиной, если в ней есть хотя бы одна из этих трех команд.</p>
<p>У корутин в С++ есть ограничения:</p>
<ul>
<li>Обязана иметь тип возрата (?)</li>
<li>Не может быть функцией с variadic templates</li>
<li>Не может быть функцией с оператором <code>return</code></li>
<li>Не может быть функцией с автоматичским выведением типа возвращаемого значения (<code>auto</code>)</li>
<li>Не может быть <code>constexpr</code>-функцией</li>
<li>Не может быть конструктором</li>
<li>Не может быть деструктором</li>
<li>Не может быть функцией <code>main</code></li>
</ul>
<p>Есть два типа корутин.</p>
<h3 id="stackless-корутины"><a class="header" href="#stackless-корутины">Stackless-корутины</a></h3>
<p>Таковыми они являются в С++20, и это значит, что корутина при запуске создает на куче пространство, которое будет являться ее памятью для возобновления состояния. Туда она помещает аргументы функции, которые ей передали. Данные, которые ей для возобновления работы не сильно нужны, она складывает в стек вызывающей стороны.</p>
<p>Аргументы по значению она скопирует/помувает, а ссылки останутся ссылками (отсюда следует, что когда корутина вернулась к выполнению кода, у нее может остаться невалидная ссылка, если объект уже уничтожили).</p>
<p>Всю магию переключений между stackless-корутинами компилятор вправе реализовать через конечный автомат и скорее всего так и сделает (в интернете есть пример с огромным оператором <code>switch</code>).</p>
<h3 id="stackfull-корутины"><a class="header" href="#stackfull-корутины">Stackfull-корутины</a></h3>
<p>Такие корутины имеют свой собственный стек и менеджатся хорошо только на уровне ОС. Иначе можно делать магию через свап в фреймах оперативной памяти с помощью ассемблерного кода - что-то об этом упоминал Иван Сорокин на лекциях по C++ Advanced в университете ИТМО.</p>
<p>Stackfull-корутины появились в WinApi уже давно и называются Fiber.</p>
<h2 id="Примеры-использования-корутины"><a class="header" href="#Примеры-использования-корутины">Примеры использования корутины</a></h2>
<pre><code class="language-cpp">X coroutine() {
    co_yield &quot;Hello &quot;;
    co_yield &quot;world&quot;;
    co_return &quot;!&quot;;
}

int main() {
    auto x = coroutine();
    std::cout &lt;&lt; x.next();
    std::cout &lt;&lt; x.next();
    std::cout &lt;&lt; x.next();
    std::cout &lt;&lt; std::endl;
}
</code></pre>
<p>Кажется, что тип X нужно писать самому.</p>
<pre><code class="language-cpp">X foo() {
    co_return 42;
}

X bar() {
    const auto result = foo();
    const int i = co_await result;
    co_return i + 23;
}
</code></pre>
<p>Пример корутины-генератора для факториала:</p>
<pre><code class="language-cpp">X factorial() {
    int a = 1;
    int b = 1;
    for (;;) {
        b *= a;
        a += 1;
        co_yield b;
    }
}
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://ru.stackoverflow.com/questions/496002/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B-coroutine-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE">c++ - Сопрограммы (корутины, coroutine) - что это? - Stack Overflow на русском</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
