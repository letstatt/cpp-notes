<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_object.html"><strong aria-hidden="true">1.</strong> Объект</a></li><li class="chapter-item expanded "><a href="02_alignment.html"><strong aria-hidden="true">2.</strong> Выравнивание</a></li><li class="chapter-item expanded "><a href="03_storage_duration.html"><strong aria-hidden="true">3.</strong> Типы размещения</a></li><li class="chapter-item expanded "><a href="04_namespaces_aliases_adl.html"><strong aria-hidden="true">4.</strong> Пространства имен, алиасы, ADL</a></li><li class="chapter-item expanded "><a href="05_inline_ODR_linkage.html"><strong aria-hidden="true">5.</strong> Inline, ODR и связывание</a></li><li class="chapter-item expanded "><a href="06_refs_and_pointers.html"><strong aria-hidden="true">6.</strong> Ссылки и указатели</a></li><li class="chapter-item expanded "><a href="07_value_categories_move.html"><strong aria-hidden="true">7.</strong> Категории значений, move-семантика</a></li><li class="chapter-item expanded "><a href="08_references_forward.html"><strong aria-hidden="true">8.</strong> Ссылки и std::forward</a></li><li class="chapter-item expanded "><a href="09_inheritance_virtual_cast.html"><strong aria-hidden="true">9.</strong> Наследование, virtual, приведение типов</a></li><li class="chapter-item expanded "><a href="10_templates.html"><strong aria-hidden="true">10.</strong> Шаблоны</a></li><li class="chapter-item expanded "><a href="11_variadic_templates.html"><strong aria-hidden="true">11.</strong> Variadic templates</a></li><li class="chapter-item expanded "><a href="12_exceptions_noexcept.html"><strong aria-hidden="true">12.</strong> Исключения, noexcept</a></li><li class="chapter-item expanded "><a href="13_constexpr_consteval_if.html"><strong aria-hidden="true">13.</strong> constexpr, consteval, if</a></li><li class="chapter-item expanded "><a href="14_decltype_declval_auto.html"><strong aria-hidden="true">14.</strong> decltype, declval, auto</a></li><li class="chapter-item expanded "><a href="15_SFINAE.html"><strong aria-hidden="true">15.</strong> SFINAE</a></li><li class="chapter-item expanded "><a href="16_RAII_smart_pointers.html"><strong aria-hidden="true">16.</strong> RAII, умные указатели</a></li><li class="chapter-item expanded "><a href="17_EBO_RVO_PGO_LTO.html"><strong aria-hidden="true">17.</strong> EBO, RVO, PGO, LTO</a></li><li class="chapter-item expanded "><a href="18_lambda.html"><strong aria-hidden="true">18.</strong> Лямбда-функции</a></li><li class="chapter-item expanded "><a href="19_type_erasure_pattern.html"><strong aria-hidden="true">19.</strong> Type-erasure паттерн</a></li><li class="chapter-item expanded "><a href="20_threading_problems.html"><strong aria-hidden="true">20.</strong> Проблемы с многопоточностью</a></li><li class="chapter-item expanded "><a href="21_atomics_memory_order.html"><strong aria-hidden="true">21.</strong> std::atomic, memory order</a></li><li class="chapter-item expanded "><a href="22_volatile.html"><strong aria-hidden="true">22.</strong> Квалификатор volatile</a></li><li class="chapter-item expanded "><a href="23_promise_future_async.html"><strong aria-hidden="true">23.</strong> std::promise, std::future, std::async</a></li><li class="chapter-item expanded "><a href="24_coroutines.html"><strong aria-hidden="true">24.</strong> Корутины</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Объект"><a class="header" href="#Объект">Объект</a></h1>
<p>Объект - это участок памяти, у которого есть</p>
<ol>
<li>Размер</li>
<li>Выравнивание</li>
<li>Тип размещения</li>
<li>Время жизни</li>
<li>Тип</li>
<li>Значение (может быть не определено)</li>
<li>Имя (необязательно)</li>
</ol>
<p>Объектами не являются</p>
<ul>
<li>Значения</li>
<li>Ссылки</li>
<li>Функции</li>
<li>Перечисление (<code>enum</code>)</li>
<li>Типы</li>
<li>Нестатические типы класса</li>
<li>Шаблоны</li>
<li>Специализация класса или функции</li>
<li>Namespace</li>
<li>Parameter pack</li>
<li><code>this</code></li>
</ul>
<p>Гарантируется, что два объекта, время жизни которых пересекаются имеют разный адрес в памяти (если один их них не является подобъектом другого).</p>
<p>Размер любого полного (<code>complete</code>) объекта должен быть больше нуля.</p>
<pre><code class="language-cpp">struct empty {};

static_assert(sizeof(empty) &gt; 0);
static_assert(sizeof(empty) == 1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Выравнивание"><a class="header" href="#Выравнивание">Выравнивание</a></h1>
<p>Выравнивание - это ограничение на то, с какой ячейки памяти по счету может храниться первый бит объекта. Выравнивание необходимо для ускорения доступа к памяти, к примеру, на архитектуре x86-64. Невыровненные данные обрабатываться могут, но это может быть медленно на некоторых архитектурах.</p>
<p>Также его важно учитывать при использовании векторных инструкций процессора, которые значительно ускоряют вычисления в некоторых случаях. Невыровненные данные в этом случае могут привести к генерации аппаратного исключения. Для справки, для SSE выравнивание должно составлять 16 байт, для AVX - 32 байта.</p>
<p>Выравнивание в 16 единиц означает, что валидным адресом для доступа будет только значение, делящееся на 16.</p>
<p>Выравнивание существует у каждого объекта. Для задания своего выравнивания в байтах у соответствующей переменной существует ключевое слово <code>alignas</code>, которое принимает степени двойки: 2, 4, 8, 16, 32, 64, 128 и так далее.</p>
<pre><code class="language-cpp">alignas(16) int a[4];
alignas(1024) int b[4];
</code></pre>
<p>Получить выравнивание объекта в compile-time можно с помощью ключевого слова <code>alignof</code>, причем возвращается наибольшая из степеней двойки.</p>
<pre><code class="language-cpp">static_assert(alignof(b) == 16); // fail
static_assert(alignof(b) == 1024); // OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типы-размещения"><a class="header" href="#Типы-размещения">Типы размещения</a></h1>
<h3 id="Спецификаторы"><a class="header" href="#Спецификаторы">Спецификаторы</a></h3>
<ul>
<li><code>(no specifier)</code> - автоматическое</li>
<li><code>static</code> - статическое (внутреннее связывание)</li>
<li><code>extern</code> - так же статическое (внешнее связывание)</li>
<li><code>thread_local</code> - тред-локальное размещение</li>
</ul>
<h4 id="Автоматическое-размещение"><a class="header" href="#Автоматическое-размещение">Автоматическое размещение</a></h4>
<p>Память под объект аллоцируется на стеке в начале открыващегося блока кода и деаллоцируется в конце.</p>
<h4 id="Статическое-размещение"><a class="header" href="#Статическое-размещение">Статическое размещение</a></h4>
<p>Память под объект аллоцируется перед исполнением программы и деаллоцируется в конце.</p>
<p>Если переменная со статическим размещением не инициализируется разработчиком, то она будет проинициализирована нулем соответствущего типа.</p>
<h4 id="Тред-локальное-размещение"><a class="header" href="#Тред-локальное-размещение">Тред-локальное размещение</a></h4>
<p>Память под объект аллоцируется при создании потока и деаллоцируется при его завершении. Каждый поток обладает собственным экземпляром объекта.</p>
<h4 id="Динамическое-размещение"><a class="header" href="#Динамическое-размещение">Динамическое размещение</a></h4>
<p>Память под объект аллоцируется и деаллоцируется по запросу программы при помощи специальных функций. При закрытии программы все недеаллоцированные ранее области памяти деаллоцируются средствами ОС.</p>
<p>(не уверен в последнем пункте, так как не силен за shared memory).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Квалифицированный-поиск"><a class="header" href="#Квалифицированный-поиск">Квалифицированный поиск</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
int main() {
    struct std {};
    std::cout &lt;&lt; &quot;fail&quot;; // Error: unqualified lookup
    ::std::cout &lt;&lt; &quot;ok&quot;; // OK, qualified
}
</code></pre>
<pre><code class="language-cpp">struct A {
    static int n;
};
 
int main() {
    int A;
    A::n = 42; // OK: ignoring the variable
    A b;       // Error: unqualified lookup of A finds the variable A
}
</code></pre>
<p>Квалифицированный поиск может быть использован для доступа к членам класса, которые были скрыты вложенным объявлением или содержатся в наследуемом классе. Вызов квалифицированного метода класса не учитывает виртуальное объявление.</p>
<pre><code class="language-cpp">struct B {virtual void foo();};
 
struct D : B {void foo() override;};
 
int main() {
    D x;
    B&amp; b = x;
    b.foo();    // calls D::foo (virtual dispatch)
    b.B::foo(); // calls B::foo (static dispatch)
}
</code></pre>
<h2 id="Псевдонимы-пространств-имен"><a class="header" href="#Псевдонимы-пространств-имен">Псевдонимы пространств имен</a></h2>
<p>Синтаксис:</p>
<p><strong>namespace</strong> <em>alias_name</em> = <em>ns_name</em>
<strong>namespace</strong> <em>alias_name</em> = ::<em>ns_name</em>
<strong>namespace</strong> <em>alias_name</em> = <em>nested_name</em>::<em>ns_name</em></p>
<p>Псевдоним <em>alias_name</em> будет виден в том блоке, в котором он объявлен.</p>
<h2 id="using-директива"><a class="header" href="#using-директива">Using-директива</a></h2>
<p>Синтаксис:</p>
<p><strong>using namespace</strong> <em>ns_name</em></p>
<p>С точки зрения неквалифицированного поиска имен любой символ, объявленный в <em>ns_name</em>, после using-директивы и до конца блока ее объявления будет виден, как если бы он был объявлен в ближайшем пространстве имен, которое одновременно содержит как using-директиву, так и <em>ns-name</em>.</p>
<h2 id="using-объявление"><a class="header" href="#using-объявление">Using-объявление</a></h2>
<p>Синтаксис:</p>
<p><strong>using</strong> <em>ns_name</em>::<em>member_name</em></p>
<p>Делает символ <em>member-name</em> из пространства имен <em>ns-name</em> доступным для неквалифицированного поиска, как если бы он был объявлен в том же классе, блоке или пространстве имен, в котором using-объявление появляется.</p>
<h2 id="Анонимные-пространства-имен"><a class="header" href="#Анонимные-пространства-имен">Анонимные пространства имен</a></h2>
<p>Синтаксис:</p>
<p><strong>namespace</strong> { <code>namespace-body</code> }</p>
<p>Пример кода:</p>
<pre><code class="language-cpp">namespace {
    int i; // defines ::(unique)::i
}

void f() {
    i++;   // increments ::(unique)::i
}
 
namespace A {
    namespace {
        int i;        // A::(unique)::i
        int j;        // A::(unique)::j
    }
    void g() { i++; } // A::(unique)::i++
}
 
using namespace A; // introduces all names from A into global namespace

void h() {
    i++;    // error: ::(unique)::i and ::A::(unique)::i are both in scope
    A::i++; // ok, increments ::A::(unique)::i
    j++;    // ok, increments ::A::(unique)::j
}

</code></pre>
<p>Символы внутри анонимных пространств имен (так же как и любые символы, объявленные внутри именованных пространств внутри других анонимных) имеют внутреннее связывание, как если бы им приписали <code>static</code>.</p>
<h2 id="adl-argument-dependent-lookup"><a class="header" href="#adl-argument-dependent-lookup">ADL (Argument-dependent lookup)</a></h2>
<p>Позволяет не указывать явно пространство имен функций при вызове, если какие-либо их аргументы объявлены в том же пространстве имен.</p>
<pre><code class="language-cpp">namespace MyNamespace {
    class MyClass {};
    void doSomething(MyClass) {}
}

MyNamespace::MyClass obj; // global object


int main() {
    doSomething(obj); // works fine - MyNamespace::doSomething() is called.
}
</code></pre>
<p>Такой поиск запускается только для имён, у которых имя неквалифицированное.</p>
<p>Важно знать, что у поиска ADL и обычного нет приоритетов, они запускаются оба и кандидаты из обоих уходят в overload resolution. Обычно они либо оба найдут одно и то же, либо обычный не найдет ничего и возьмется из ADL.</p>
<p>Но есть такой tricky пример кода:</p>
<pre><code class="language-cpp">using std::swap;
swap(obj1, obj2);
</code></pre>
<p>Если существует пространство имен <code>A</code> и если существуют <code>A::obj1</code>, <code>A::obj2</code> и <code>A::swap()</code>, то произойдет вызов <code>A::swap()</code> вместо вызова <code>std::swap()</code>, чего разработчик иногда может не ожидать. <em>todo: с чем связано?</em></p>
<hr />
<p>Заимствования:</p>
<p><a href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent lookup - cppreference.com</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Правила-odr"><a class="header" href="#Правила-odr">Правила ODR:</a></h2>
<ol>
<li>В пределах любой единицы трансляции шаблон, тип данных, функция или объект не могут иметь более одного определения, но могут иметь неограниченное число объявлений.</li>
<li>В пределах программы (совокупности всех единиц трансляции) объект или не-inline функция не могут иметь более одного определения; если объект или функция используются, у каждого из них должно быть строго по единственному определению.</li>
<li>Типы, шаблоны и inline-функции (то есть те сущности, определение которых полностью или частично совмещается с их объявлением) могут определяться в более чем одной единице трансляции, но для каждой такой сущности все её определения должны быть идентичны.</li>
</ol>
<p>ODR можно легально нарушить с помощью ключевого слова <code>inline</code>.</p>
<h2 id="Связывание-linkage"><a class="header" href="#Связывание-linkage">Связывание (linkage)</a></h2>
<h4 id="Без-связывания"><a class="header" href="#Без-связывания">Без связывания</a></h4>
<p>Символ доступен только из блока, в котором был объявлен.</p>
<h4 id="Внутреннее-связывание-internal-linkage"><a class="header" href="#Внутреннее-связывание-internal-linkage">Внутреннее связывание (internal linkage)</a></h4>
<p>Символ доступен из всех блоков в данной единице трансляции.</p>
<h4 id="Внешнее-связывание-external-linkage"><a class="header" href="#Внешнее-связывание-external-linkage">Внешнее связывание (external linkage)</a></h4>
<p>Символ доступен из всех блоков в других единицах трансляции.</p>
<h4 id="Модульное-связывание-module-linkage"><a class="header" href="#Модульное-связывание-module-linkage">Модульное связывание (module linkage)</a></h4>
<p>Символ доступен из всех блоков только данного модуля или в других единицах трансляции того же самого именованного модуля.</p>
<p>Символы, определенные в пространстве имен, имеют модульное связывание, если их объявление находится в именованном модуле и не было экспортировано (<code>exported</code>), и если они не имеют внутреннего связывания.</p>
<p>// TODO: не уверен в этом пункте. нужно изучить этот вопрос.</p>
<h2 id="Какие-ключевые-слова-влияют-на-связывание"><a class="header" href="#Какие-ключевые-слова-влияют-на-связывание">Какие ключевые слова влияют на связывание?</a></h2>
<ul>
<li>Использование <code>static</code> в глобальном пространстве имен дает символу внутреннее связывание.</li>
<li>Использование <code>extern</code> дает внешнее связывание.</li>
</ul>
<p>Компилятор по умолчанию дает символам следующие связывания:</p>
<ul>
<li>Non-const глобальные переменные - внешнее связывание</li>
<li>Const глобальные переменные - внутреннее связывание</li>
<li>Функции - внешнее связывание</li>
<li>Объявление в анонимном пространстве имен - внутреннее связывание.</li>
</ul>
<p>То есть, например, константы в файлах <code>.h</code>, по умолчанию будут продублированы в каждой единице трансляции при подключении через <code>#include</code>. То есть каждый файл <code>.cpp</code> будет иметь свою собственную константу.</p>
<p>Это может негативно сказаться на скорости компиляции при изменении этой константы, так как перекомпилироваться будут все единицы трансляции, в которых эта константа присутствовала.</p>
<p>Чтобы этого избежать, можно пометить константы в файле <code>.h</code> как <code>extern</code>, затем инициализировать их единожды в каком-нибудь <code>.cpp</code>, затем подключать этот хедер где угодно.</p>
<pre><code class="language-cpp">// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace constants {
    extern const double pi;
    extern const double avogadro;
}

#endif
</code></pre>
<pre><code class="language-cpp">// constants.cpp
#include &quot;constants.h&quot;

namespace constants {
    // keyword extern can be omitted
    extern const double pi { 3.14159 };
    extern const double avogadro { 6.0221413e23 };
}
</code></pre>
<p>Однако у этого метода есть недостаток. Эти константы теперь могут считаться константами времени компиляции только в файле, в котором они фактически определены (<code>constants.cpp</code>), а не где-либо еще.</p>
<h2 id="Ключевое-слово-inline"><a class="header" href="#Ключевое-слово-inline">Ключевое слово inline</a></h2>
<p>Ключевое слово <code>inline</code> говорит линкеру игнорировать то, что в нескольких <code>.cpp</code> файлах встречаются одинаковые определения. Линкер будет брать рандомное, предполагая, что все они равны. Если они не равны, поведение не определено.</p>
<p>Также слово <code>inline</code> может объявлять inline-переменную и влиять на связывание (linkage) этой переменной начиная со стандарта C++17, если она глобальная, дополняя правила связывания переменных:</p>
<ul>
<li><code>static</code> - внутреннее связывание</li>
<li><code>extern</code> - внешнее связывание</li>
<li><code>inline</code> - внешнее связывание</li>
<li><code>const</code> &amp;&amp; <code>inline</code> - внешнее связывание</li>
<li><code>const</code> &amp;&amp; !<code>inline</code> - внутреннее связывание</li>
</ul>
<p>Предыдущий пример можно переписать следующим образом:</p>
<pre><code class="language-cpp">// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace constants {
    inline constexpr double pi { 3.14159 };
    inline constexpr double avogadro { 6.0221413e23 };
}

#endif
</code></pre>
<p>Также можно неформально сказать, что все шаблонные классы/методы/функции являются inline автоматически.</p>
<p>Constexpr-функции также неявно являются inline.</p>
<hr />
<p>Заимствования:</p>
<p><a href="https://habr.com/ru/company/otus/blog/561772/">Inline variables / Хабр (habr.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ссылки-и-указатели"><a class="header" href="#Ссылки-и-указатели">Ссылки и указатели</a></h1>
<p>Ссылка - это псевдоним к определенной ранее переменной.
Указатель - это объект, значением которого является адрес ячейки памяти.</p>
<p>Разница?</p>
<h4 id="Инициализация"><a class="header" href="#Инициализация">Инициализация</a></h4>
<p>Ссылку обязательно инициализировать. Она не может указывать вникуда или быть пустой, в отличие от указателя, которому задавать начальное значение необязательно.</p>
<h4 id="Изменение-значения"><a class="header" href="#Изменение-значения">Изменение значения</a></h4>
<p>Ссылка не может быть переопределена, вместо этого присвоится значение переменной, на которую ссылка ссылается, если она не константная. Присваивать же новое значение указателю можно, если он не константный.</p>
<h4 id="Взятие-адреса"><a class="header" href="#Взятие-адреса">Взятие адреса</a></h4>
<p>Ссылка - псевдоним к переменной, а не объект. Взятие адреса от ссылки будет возвращать адрес объекта, на который ссылка ссылается. Взятие же адреса указателя будет возвращать адрес указателя, а не объекта, на который указатель ссылается.</p>
<p>По стандарту ссылка - не объект, но при определенных условиях, ссылки могут компилироваться в указатели.</p>
<p>Рекомендация: используйте ссылки вместо указателей, если вам не нужно передавать пустое значение (читай, нулевой указатель).</p>
<h2 id="Интересное-про-ссылки"><a class="header" href="#Интересное-про-ссылки">Интересное про ссылки</a></h2>
<h3 id="Краткие-факты"><a class="header" href="#Краткие-факты">Краткие факты</a></h3>
<ul>
<li>Ссылки на ссылку не бывает. Они коллапсируют в одну.</li>
<li>Ссылки типа <code>void</code> не бывает.</li>
<li>Ссылка может продлить время жизни объекта, если это <code>lvalue</code>-ссылка на const или <code>rvalue</code>-ссылка.</li>
</ul>
<h3 id="dangling-reference"><a class="header" href="#dangling-reference">Dangling reference</a></h3>
<p>Ссылки были созданы, чтобы сделать указатели безопаснее, но даже их можно сломать.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int&amp; bar() {
    int n = 10;
    return n;
}

int main() {
    int&amp; i = bar();
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
<p>Функция <code>bar()</code> вернет ссылку на локальную переменную, которая уничтожится при выходе из нее. Соответственно, такая ссылка будет невалидной и операции с ней - это undefined behavior.</p>
<p>Но вот так делать можно, конечно.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

const int&amp; bar(const int&amp; a) {
    return a;
}

int main() {
    const int&amp; i = bar(42);
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
<h3 id="Передача-массива-по-ссылке"><a class="header" href="#Передача-массива-по-ссылке">Передача массива по ссылке</a></h3>
<p>Не секрет, что для передачи массивов в функции можно использовать указатели, но мало кто догадается, что можно использовать и ссылки. Но сначала: каким образом обычно передают указатели на массивы?</p>
<ul>
<li>Либо это указатель на массив фиксированного размера</li>
<li>Либо это указатель на массив с передачей размера отдельным аргументом</li>
</ul>
<p>В примере ниже мы сделаем первый вариант, но схитрим, написав шаблон.</p>
<pre><code class="language-cpp">#include &lt;type_traits&gt;

// Конвертирует строковый литерал в число
template &lt;size_t N&gt;
constexpr int convert(const char (&amp;in)[N]) {
    int res = 0;
    for (const char * c = in; *c; ++c) {
        (res *= 10) += *c - '0';
    }
    return res;
}

// Вычисляет длину массива
template &lt;typename T, size_t N&gt;
size_t len(T (&amp;a)[N]) {
    return N;
}

static_assert(convert(&quot;123&quot;) == 123);
</code></pre>
<p>Замечание: <code>constexpr</code> здесь нужен только для демонстрации <code>static_assert</code>.</p>
<p>Остальные фишки ссылок будут в другой заметке.</p>
<h2 id="Интересное-про-указатели"><a class="header" href="#Интересное-про-указатели">Интересное про указатели</a></h2>
<h3 id="Краткие-факты-1"><a class="header" href="#Краткие-факты-1">Краткие факты</a></h3>
<ul>
<li>Можно сделать указатель на указатель на указатель...</li>
<li>Поддерживают арифметику (только указатели в рамках одного массива. остальное - undefined behavior)</li>
</ul>
<h3 id="Указатели-на-массивы-фиксированной-длины"><a class="header" href="#Указатели-на-массивы-фиксированной-длины">Указатели на массивы фиксированной длины</a></h3>
<pre><code class="language-cpp">int (*a)[2];                  // create pointer to int[2]
int b[2];
int c[2];

a = new int[2];               // compile error (returns int*)
a = &amp;b;                       // OK (returns int(*)[2])
a = (int(*)[2]) (new int[2]); // OK
a = &amp;c;                       // compile error (returns int(*)[3])
</code></pre>
<h3 id="Многомерные-массивы-на-стеке"><a class="header" href="#Многомерные-массивы-на-стеке">Многомерные массивы на стеке</a></h3>
<p>При объявлении многомерных массивов на стеке память выделяется непрерывно, что позволяет компилятору при индексации делать прыжок по указателю единожды.</p>
<pre><code class="language-cpp">int x[10][10];   // выделенный на стеке многомерный массив
int a = x[2][3]; // один прыжок
</code></pre>
<p>Но при индексации от указателя на него программа будет совершать честные прыжки в количестве измерений.</p>
<pre><code class="language-cpp">int **y = x;
int b = y[2][3]; // два прыжка
</code></pre>
<h3 id="Как-читать-мешанину-со-словом-const"><a class="header" href="#Как-читать-мешанину-со-словом-const">Как читать мешанину со словом const</a></h3>
<p>Ключевое слово <code>const</code> относится к тому, что слева, если не в начале строки, иначе к тому, что справа.</p>
<pre><code class="language-cpp">int a = 42;
const int b;              // нет инициализации, compile error
const int c = a;          // константный int
int const d = a;          // то же самое

const int * e = &amp;a;       // изменяемый указатель на неизменяемый int
int const * f = &amp;a;       // то же самое

int * const g = &amp;a;       // неизменяемый указатель на изменяемый int
const int * const h = &amp;a; // константный указатель на константу
</code></pre>
<h3 id="Указатель-на-функцию"><a class="header" href="#Указатель-на-функцию">Указатель на функцию</a></h3>
<p>Функции приводятся к указателям и наоборот налету, неявно. Синтаксис для их объявления приведен ниже:</p>
<pre><code class="language-cpp">double sum(int a, long b) {
    return a + b;
}

double (*ptr)(int, long) = sum;
double (*ptr)(int, long) = &amp;sum; // эквивалентно

double c = (*ptr)(1, 2l);
double c = ptr(1, 2l); // эквивалентно
</code></pre>
<h3 id="Массив-указателей-на-массив"><a class="header" href="#Массив-указателей-на-массив">Массив указателей на массив</a></h3>
<p>Интересно объявлен тип указателя C, разгадка будет ниже.</p>
<pre><code class="language-cpp">int A[5][5];
int B[5][5];
int (*C[])[5][5] = {&amp;A, &amp;B};
</code></pre>
<h3 id="Пример-от-Артема-К"><a class="header" href="#Пример-от-Артема-К">Пример от Артема К</a></h3>
<pre><code class="language-cpp">double (* (*x[10]) (int &amp;))[5];
</code></pre>
<p>x — это массив из 10 указателей на функции, которые принимают аргументом <code>int&amp;</code>, а возвращают массив из 5 <code>double</code>.</p>
<h3 id="Как-парсить-подобные-вещи"><a class="header" href="#Как-парсить-подобные-вещи">Как парсить подобные вещи</a></h3>
<ul>
<li>Парсим изнутри, начиная с имени переменной</li>
<li>Идем вправо, потом влево</li>
<li>Потом на следующий уровень наружу</li>
</ul>
<p>Пример:</p>
<pre><code class="language-cpp">void* (*y[5])(char);
</code></pre>
<p>y — это:</p>
<ol>
<li>массив из пяти</li>
<li>указателей</li>
<li>на функцию, принимающую char</li>
<li>и возвращающую void*</li>
</ol>
<h3 id="Пример-от-Артема-К-1"><a class="header" href="#Пример-от-Артема-К-1">Пример от Артема К</a></h3>
<pre><code class="language-cpp">int (* (** (* (* x)[5])(void))[10])();
</code></pre>
<p>x - это указатель на массив размера 5 из указателей на функции, принимающие void (то есть не принимающие аргументов - это альтернативный синтаксис) и отдающие указатель на указатель на массив размера 10 из указателей на функции без аргументов, возвращающие int</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="До-прихода-c11"><a class="header" href="#До-прихода-c11">До прихода C++11</a></h2>
<ol>
<li><code>lvalue</code> - это то, что может стоять слева от оператора присваивания.</li>
<li><code>rvalue</code> - это &quot;временные объекты&quot;, им нельзя что-то присваивать. Кажется, что у них нельзя было взять адрес.</li>
</ol>
<p>С приходом C++11 появилась move-семантика, из-за чего схема стала древовидной и усложнилась в понимании.</p>
<h2 id="Сейчас"><a class="header" href="#Сейчас">Сейчас</a></h2>
<p>Введем пару понятий:</p>
<ul>
<li>Наличие идентичности (<em>identity</em>) – наличие какого-то параметра, по которому можно понять, ссылаются ли два выражения на одну и ту же сущность (например, адрес в памяти)</li>
<li>Возможность перемещения (можно ли объект переместить, <em>помувать</em>)</li>
</ul>
<p>Выражения сейчас делятся на два больших типа:</p>
<ul>
<li><code>glvalue</code> - обладают идентичностью</li>
<li><code>rvalue</code> - могут быть перемещены</li>
</ul>
<p>Эти категории распадаются в сумме на три (одна у них общая).</p>
<ol>
<li>
<p><code>glvalue</code></p>
<ul>
<li><code>lvalue</code> - обладают идентичностью, но не могут быть перемещены</li>
<li><code>xvalue</code> - обладают идентичностью, могут быть перемещены</li>
</ul>
</li>
<li>
<p><code>rvalue</code></p>
<ul>
<li><code>xvalue</code> - то же самое</li>
<li><code>prvalue</code> - не обладают идентичностью, могут быть перемещены</li>
</ul>
</li>
</ol>
<h2 id="Да-кто-такие-эти-ваши-glvalue-и-rvalue"><a class="header" href="#Да-кто-такие-эти-ваши-glvalue-и-rvalue">Да кто такие эти ваши glvalue и rvalue</a></h2>
<p>Свойства <code>glvalue</code>:</p>
<ul>
<li>Могут быть неявно преобразованы в <code>prvalue</code></li>
<li>Могут быть полиморфными (?)</li>
<li>Не могут иметь тип <code>void</code> (из-за наличия идентичности)</li>
<li>Может быть неполным типом (<code>incomplete type</code>), где это разрешено выражением</li>
</ul>
<p>Свойства <code>rvalue</code>:</p>
<ul>
<li>Нельзя взять адрес оператором &amp; (из-за отсутствия идентичности)</li>
<li>Не могут находиться слева от оператора =</li>
<li>Могут использоваться для инициализации <code>const lvalue</code>-ссылки или <code>rvalue</code>-ссылки, при этом время жизни объекта расширяется до времени жизни ссылки</li>
<li>Если в overload resolution пришли две функции, одна из которых принимает <code>const-lvalue</code>-ссылку, а другая <code>rvalue</code>-ссылку, то выберется вторая (то есть, например, если move-конструктор определен, то он предпочтительнее)</li>
</ul>
<h2 id="Про-lvalue"><a class="header" href="#Про-lvalue">Про lvalue</a></h2>
<p>Свойства:</p>
<ul>
<li>Все свойства <code>glvalue</code></li>
<li>Можно взять адрес оператором &amp;</li>
<li>Модифицируемые <code>lvalue</code> могут стоять слева от оператора присваивания</li>
<li>Могут использоваться для инициализации <code>lvalue</code>-ссылки</li>
</ul>
<p>Примеры <code>lvalue</code>:</p>
<ul>
<li>Имя переменной, функции или поле класса любого типа. Даже если переменная является <code>rvalue</code>-ссылкой, имя этой переменной в выражении является <code>lvalue</code> (другими словами, именованная <code>rvalue</code>-ссылка является <code>lvalue</code>-значением, но это все еще <code>rvalue</code>-ссылка)</li>
<li>Вызов функции или оператора, возвращающего <code>lvalue</code>-ссылку</li>
<li>Преобразование к типу <code>lvalue</code>-ссылки</li>
<li>Результат встроенных операторов присваивания, составных операторов присваивания (<code>=</code>, <code>+=</code>, <code>/=</code> и т.д.), встроенных преинкремента и предекремента, встроенных операторов разыменования указателя</li>
<li>Результат встроенного оператора обращения по индексу от <code>lvalue</code>-массива</li>
<li>Строковый литерал, например, <code>&quot;Hello world!&quot;</code> (можно взять его адрес тоже)</li>
</ul>
<h2 id="Про-prvalue"><a class="header" href="#Про-prvalue">Про prvalue</a></h2>
<p>Свойства:</p>
<ul>
<li>Все свойства <code>rvalue</code></li>
<li>Не могут быть полиморфными (?)</li>
<li>Не могут быть неполного типа</li>
<li>Не могут иметь абстрактный тип или быть массивом элементов абстрактного типа</li>
</ul>
<p>Примеры <code>prvalue</code>:</p>
<ul>
<li>Литерал (кроме строкового), например, <code>42</code>, <code>false</code> или <code>nullptr</code></li>
<li>Вызов функции или оператора, который возвращает не ссылку</li>
<li>Результат преобразования к нессылочному типу</li>
<li>Результат встроенных операторов постинкремента и постдекремента, встроенных математических, логических операторов, операторов сравнения, взятия адреса</li>
<li>Указатель <code>this</code></li>
<li>Элемент перечисления (enum)</li>
<li>Нетиповой параметр шаблона, если он не является классом</li>
<li>Лямбда-выражение (пример, <code>[](int x) { return x*x; }</code>)</li>
</ul>
<h2 id="Про-xvalue"><a class="header" href="#Про-xvalue">Про xvalue</a></h2>
<p>Свойства:</p>
<ul>
<li>Все свойства <code>glvalue</code></li>
<li>Все свойства <code>rvalue</code></li>
</ul>
<p>Примеры <code>xvalue</code>:</p>
<ul>
<li>Вызов функции или встроенного оператора, возвращающего <code>rvalue</code>-ссылку, например <code>std::move(x)</code></li>
<li>Результат преобразования к <code>rvalue</code>-ссылке</li>
<li>Нестатический член класса от <code>rvalue</code>-объекта</li>
</ul>
<h2 id="stdmove"><a class="header" href="#stdmove">std::move()</a></h2>
<p>Функция <code>std::move()</code> не выполняет никаких перемещений, о чем порой заблуждаются - это просто приведение <code>lvalue</code>-аргумента к <code>rvalue</code>-ссылке.</p>
<p>Может быть реализована следующим образом:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; arg) noexcept {
    return static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(arg);
}
</code></pre>
<p>То есть это просто обертка над <code>static_cast</code>, которая «убирает» ссылку у переданного аргумента с помощью <code>remove_reference_t</code> и, добавив &amp;&amp;, преобразует тип в <code>rvalue</code>-ссылку.</p>
<p>В примере выше T&amp;&amp; - не <code>rvalue</code>-ссылка, а универсальная ссылка, о чем будет сказано в отдельном разделе.</p>
<p>Еще одна типичная ошибка при использовании <code>std::move()</code>:</p>
<pre><code class="language-cpp">std::string get_my_string(const size_t index) {
    std::string my_string;

    // *do something*

    return std::move(my_string); // wrong!
}
</code></pre>
<p>Работать это будет, но это неэффективно. Лучше писать без <code>std::move()</code> - копирования не случится из-за оптимизации <code>RVO</code> и его друзей (когда они возможны).</p>
<hr />
<p>Заимствования:</p>
<p><a href="https://habr.com/ru/post/441742/">Категории выражений в C++ / Хабр (habr.com)</a></p>
<p><a href="https://habr.com/ru/post/568306/">std::move vs. std::forward / Хабр (habr.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reference-collapsing-rule"><a class="header" href="#reference-collapsing-rule">Reference collapsing rule</a></h2>
<p>Еще до С++11 ввели правило, что ссылка на ссылку - это ссылка без вложенности. В связи с введением <code>rvalue</code>-ссылок правило пришлось дополнить.</p>
<pre><code>(A&amp;)&amp; -&gt; A&amp;
(A&amp;)&amp;&amp; -&gt; A&amp;
(A&amp;&amp;)&amp; -&gt; A&amp;
(A&amp;&amp;)&amp;&amp; -&gt; A&amp;&amp;
</code></pre>
<p>Так же в связи с появлением нового типа ссылок стало необходимо распознавать, ссылка какого типа пришла в функцию. Разработчики решили даром синтаксис не терять и не городить новых конструкций, поэтому написание <code>T&amp;&amp;</code> от шаблонного типа стало означать новую фичу.</p>
<p>Важный момент! Помните, что</p>
<pre><code class="language-cpp">int a = 42;

int&amp; b = a; // lvalue-ссылка, имеющая lvalue категорию
const int&amp; b = a; // то же самое

int&amp;&amp; f() {
    return 42;
}

f(); // rvalue-ссылка, имеющая xvalue категорию
int&amp;&amp; b = std::move(a); // rvalue-ссылка, имеющая lvalue категорию

int g(int&amp;&amp; a) { // a - rvalue-ссылка, имеющая lvalue категорию
    return a;
}
</code></pre>
<h2 id="Универсальная-ссылка"><a class="header" href="#Универсальная-ссылка">Универсальная ссылка</a></h2>
<p>В C++11 правила вывода шаблонных параметров были определены специальным образом, который позволил сохранять информацию о том, ссылка какого типа в функцию передавалась.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(a);
}

int main() {
    g(42); // rvalue: T -&gt; int, void g(int&amp;&amp;)
    int a;
    g(a); // lvalue: T -&gt; int&amp;, void g(int&amp;)
}
</code></pre>
<p>Шаблонная &quot;<code>rvalue</code>&quot;-ссылка ведет себя по-разному в зависимости от того, что в нее передали - она становится либо <code>lvalue</code>-ссылкой, либо <code>rvalue</code>-ссылкой.</p>
<p>Реализуется компилятором это тривиально: создаются обе версии, если нужно.</p>
<p>На примере выше можно передавать в <code>g(T&amp;&amp;)</code> любой тип, и он прикастуется к ссылке определенного типа. Но есть подвох: как ни крути тип ссылки в рантайме мы все-таки не знаем, а в вызовах <code>f(A&amp;&amp;)</code> из <code>g(T&amp;&amp;)</code> вообще будет присутствовать только версия, принимающая <code>lvalue</code>-ссылку.</p>
<p>Почему? Так как <code>T&amp;&amp; a</code> - именованная ссылка, значит она имеет категорию <code>lvalue</code>, значит тип аргумента будет (T&amp;&amp;)&amp; -&gt; T&amp;, либо (T&amp;)&amp; -&gt; T&amp; по правилу схлопывания ссылок. Для того, чтобы сохранять информацию о типе ссылки на уровне компиляции, придумали <code>std::forward</code>.</p>
<h2 id="stdforward"><a class="header" href="#stdforward">std::forward</a></h2>
<p>Использование <code>Perfect forwarding</code> позволяет сохранять тип ссылки на уровне компиляции.</p>
<pre><code class="language-cpp">
void bar(int&amp; v) {
    std::cout &lt;&lt; &quot;lvalue&quot;;
}

void bar(int&amp;&amp; v) {
    std::cout &lt;&lt; &quot;rvalue&quot;;
}

template &lt;typename T&gt;
void foo(T&amp;&amp; v) {
    bar(v);
}

template &lt;typename T&gt;
void foo2(T&amp;&amp; v) {
    bar(std::forward&lt;T&gt;(v));
}

int a = 42;
foo(a);  // out: lvalue
foo(42); // out: lvalue

foo2(a);  // out: lvalue
foo2(42); // out: rvalue

</code></pre>
<p>Часто <code>std::forward</code> применяется вместе с variadic templates.</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    g(std::forward&lt;Args&gt;(args)...);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Наследование-и-переопределение"><a class="header" href="#Наследование-и-переопределение">Наследование и переопределение</a></h2>
<p>Внимание: наследование классов иногда влечет за собой использование виртуального деструктора. Рекомендуется к прочтению ниже.</p>
<p>Представим, что у нас есть такой код:</p>
<pre><code class="language-cpp">struct vehicle {
    void beep() {
        std::cout &lt;&lt; &quot;vehicle does beep-beep\n&quot;;
    }
};

struct bus : vehicle {
    void beep() {
        std::cout &lt;&lt; &quot;bus does beep-beep\n&quot;;
    }
};

int main() {
    bus b;
    b.beep();
    vehicle&amp; v = b;
    v.beep();
}
</code></pre>
<p>Люди, пишущие код на Java, привыкли к тому, что переопределение метода сохраняется при приведении класса-потомка к более базовому классу. Поэтому они могут ожидать, что код дважды вернет <code>bus does beep-beep</code>, но по умолчанию в С++ это не так.</p>
<p>Правильный ответ такой:</p>
<pre><code>bus does beep-beep
vehicle does beep-bepp
</code></pre>
<p>Добавление в потомке метода с сигнатурой, уже определенной ранее в классе-родителе, не переопределяет методы базового класса. Можно в каждом потомке писать метод <code>void foo(int, int)</code>, и полученный объект действительно будет все их содержать.</p>
<p>Как вызвать определенный метод, если таких в цепочке наследования было несколько?</p>
<ul>
<li>через приведение к базовому типу</li>
<li>через квалифицированный поиск (смотри <code>namespaces, aliases, adl</code>)</li>
</ul>
<p>Пример квалифицированного поиска:</p>
<pre><code class="language-cpp">struct vehicle {
    void beep() {
        std::cout &lt;&lt; &quot;vehicle does beep-beep\n&quot;;
    }
};

struct bus : vehicle {
    void beep() {
        std::cout &lt;&lt; &quot;bus does beep-beep\n&quot;;
    }
};


struct liaz : bus {
    void beep() {
        std::cout &lt;&lt; &quot;liaz does beep-beep\n&quot;;
    }
};

int main() {
    liaz l;
    l.beep();
    l.bus::beep();
    l.vehicle::beep();
}
</code></pre>
<p>Вывод:</p>
<pre><code>liaz does beep-beep
bus does beep-beep
vehicle does beep-beep
</code></pre>
<p>Компилятор будет искать вызываемый метод начиная с того класса в цепочке наследования, на котором он был вызван, переходя при неудаче к предкам. То есть необязательно вызывать метод непосредственно на том классе, в котором он объявлен - можно запускать поиск и с потомков. Но есть нюанс:</p>
<h2 id="Множественное-наследование"><a class="header" href="#Множественное-наследование">Множественное наследование</a></h2>
<p>В С++ классам разрешено иметь более одного родителя:</p>
<pre><code class="language-cpp">struct platform {
    void f() {}
};

struct body {
    void f() {}
};

struct vehicle : platform, body {};
</code></pre>
<p>Но что будет, если теперь запустить поиск метода <code>void f()</code> из класса vehicle?</p>
<pre><code class="language-cpp">int main() {
    vehicle v;
    v.f(); // ???
}
</code></pre>
<p>Мы получим ошибку компиляции, так как в overload resolution придут оба кандидата, как глубоко бы не был вложен метод <code>f()</code> в цепочке наследования, поэтому здесь не обойтись без приведения к нужному классу-родителю или без квалифицированного поиска.</p>
<p>Внимание: даже если один из родителей будет наследоваться приватно, все равно будет получена ошибка компиляции.</p>
<p>Все те же правила применимы к полям классов.</p>
<h2 id="Виртуальные-методы-virtual-и-override"><a class="header" href="#Виртуальные-методы-virtual-и-override">Виртуальные методы (virtual и override)</a></h2>
<p>Внимание: использование виртуальных функций зачастую требует знания <code>dynamic_cast</code>. Рекомендуется к прочтению ниже.</p>
<p>Добиться похожего в Java переопределения методов можно с помощью ключевого слова <code>virtual</code> рядом с нужным методом.</p>
<pre><code class="language-cpp">struct vehicle {
    virtual void beep() {
        std::cout &lt;&lt; &quot;vehicle does beep-beep\n&quot;;
    }
};

struct bus : vehicle {
    void beep() {
        std::cout &lt;&lt; &quot;bus does beep-beep\n&quot;;
    }
};

int main() {
    bus b;
    b.beep();
    vehicle&amp; v = b;
    v.beep();
}
</code></pre>
<p>Теперь начиная с класса <code>vehicle</code> и далее по потомкам метод <code>beep</code> всегда будет вызывать последнее переопределение:</p>
<pre><code class="language-cpp">bus does beep-beep
bus does beep-beep
</code></pre>
<p>Для классов, являющихся предками <code>vehicle</code> сохраняется обычное поведение.</p>
<p>Было бы неудобно писать один раз где-то далеко <code>virtual</code> и никак о нем не вспоминать при дальнейшей разработке, поэтому можно либо писать его и во всех последующих переопределениях, либо писать ключевое слово <code>override</code>, которое ничего не делает, кроме проверки компилятора на то, что данный метод действительно является виртуальным (зато сразу понятно, что следует от него ожидать).</p>
<pre><code class="language-cpp">struct vehicle {
    virtual void beep() {}
};

struct bus : vehicle {
    void beep() override {}
};
</code></pre>
<p>Квалифицированный поиск при точном указании класса-родителя, у которого нужно вызывать метод вызывает именно этот метод и не обращает внимание на виртуальность. Если в указанном родителе метода не было, то компилятор так же, как и раньше, будет идти по предкам и искать, кого бы вызвать. При нахождении такого метода виртуальность тоже будет проигнорирована.</p>
<p>Использование виртуальных функций не дается за бесплатно. Каждый их вызов - потенциальные прыжки по указателям, поскольку для поддержания такого поведения необходима дополнительная структура, де-факто являющаяся так называемой таблицей виртуальных функций (vtable).</p>
<p>Отсюда мемы, что в Java все функции - виртуальные, и что &quot;этот господин за все заплатит&quot;.</p>
<h2 id="Виртуальный-деструктор-ошибка-разрушения-базового-класса"><a class="header" href="#Виртуальный-деструктор-ошибка-разрушения-базового-класса">Виртуальный деструктор, ошибка разрушения базового класса</a></h2>
<p>Рассмотрим следующий код:</p>
<pre><code class="language-cpp">struct vehicle {
    ~vehicle() {
        std::cout &lt;&lt; &quot;vehicle destroyed\n&quot;;
    }
};

struct bus : vehicle {
    ~bus() {
        std::cout &lt;&lt; &quot;bus destroyed\n&quot;;
    }
};

int main() {
    bus b;
}
</code></pre>
<p>Он является корректным: мы создали машину, затем автобус, а достигнув конца блока <code>main</code> разрушили сначала автобус, затем машину. Но что будет со следующим кодом?</p>
<pre><code class="language-cpp">vehicle* v = new bus();
delete v;
</code></pre>
<p>Будет вызван только деструктор класса <code>vehicle</code>, а память класса <code>bus</code> утечет. Так происходит, поскольку компилятор не знает, что по указателю лежит не просто класс <code>vehicle</code>. Может быть еще хуже, если класс <code>bus</code> будет иметь в себе указатель на условный гигабайт данных, который мы тоже не удалим.</p>
<p>Для решения этой проблемы деструктор базового класса предлагается делать виртуальным:</p>
<pre><code class="language-cpp">struct vehicle {
    virtual ~vehicle() {/* ... */}
};

struct bus : vehicle {
    ~bus() {/* ... */}
};
</code></pre>
<p>В таком случае удалению базового класса будет всегда приводить сначала к удалению производного, затем базового, что правильно.</p>
<h2 id="Виртуальное-наследование-virtual"><a class="header" href="#Виртуальное-наследование-virtual">Виртуальное наследование (virtual)</a></h2>
<p>Рассмотрим следующий код:</p>
<pre><code class="language-cpp">struct base {
    void f() {}
}

struct left : base {}
struct right : base {}

struct top : left, right {}

int main() {
    top t;
    t.f();
}
</code></pre>
<p>Здесь есть две проблемы:</p>
<ol>
<li>Классы <code>left</code> и <code>right</code> оба имеют метод <code>void f()</code>, поэтому мы получим ошибку компиляции (но ведь для нас этот метод все равно один, в каком-то смысле!)</li>
<li>Класс <code>top</code> будет содержать в себе два независимых подкласса <code>base</code>. Это подразумевает, что у них будет отдельная память, можно отдельно изменять их поля и так далее.</li>
</ol>
<p>Если нам не хочется иметь такое поведение, то мы можем дать команду компилятору на склеивание одинаковых базовых классов, которые были когда-то унаследованы виртуально, в один экземпляр:</p>
<pre><code class="language-cpp">struct base {
    void f() {}
}

struct left : virtual base {}
struct right : virtual base {}

struct top : left, right {}

int main() {
    top t;
    t.f(); // no compile errors
}
</code></pre>
<p>При этом данная техника тоже не бесплатная: при обращении к полям/методам виртуально унаследованного класса будет совершаться прыжок по указателю.</p>
<h2 id="Приведение-типов"><a class="header" href="#Приведение-типов">Приведение типов</a></h2>
<p>В С++ есть 5 способов приведения типов</p>
<ol>
<li>C-style cast</li>
<li><code>static_cast&lt;T&gt;</code></li>
<li><code>dynamic_cast&lt;T&gt;</code></li>
<li><code>reinterpret_cast&lt;T&gt;</code></li>
<li><code>const_cast&lt;T&gt;</code></li>
</ol>
<h3 id="c-style-cast"><a class="header" href="#c-style-cast">C-style cast</a></h3>
<p>Может приводить практически любой тип к любому (но, например, пользовательские типы без правил приведения не удастся кастануть). Его минусом является отсутствие проверки типов на совместимость, например, так можно привести указатель на <code>int</code> к указателю на <code>std::iostream</code>. Чаще всего не рекомендуется к использованию.</p>
<pre><code class="language-cpp">int *p = new int(5);
std::iostream *i = (std::iostream*) p;
</code></pre>
<h3 id="static_cast"><a class="header" href="#static_cast">static_cast</a></h3>
<p>Предоставляет типобезопасное приведение на уровне компиляции. Умеет кастовать числа друг к другу, а также указатели и ссылки на классы вверх или вниз по цепочке наследования. Любой указатель может быть приведен к указателю на <code>void</code> и обратно.</p>
<h3 id="dynamic_cast"><a class="header" href="#dynamic_cast">dynamic_cast</a></h3>
<p>Необходим для приведения полиморфных типов (классов, которые имеют виртуальные функции, либо наследуют их от предков). Если приведение по указателю было неудачным, возвращает <code>nullptr</code>. Если приведение по ссылке было неудачным, бросает <code>std::bad_cast</code>. Так как этот вид каста работает в реалтайме, то его использование в качестве замены <code>static_cast</code> является нецелесообразным из-за медленности, но, конечно, возможно.</p>
<h3 id="reinterpret_cast"><a class="header" href="#reinterpret_cast">reinterpret_cast</a></h3>
<p>Используется для приведения несовместимых типов друг к другу. Например, для приведения указателя к числу (или наоборот), либо указателю к другому указателю или ссылке к другой ссылке. В отличие от C-style cast не умеет изменить cv-квалификаторы (<code>const</code> и <code>volatile</code>), как и предыдущие два каста.</p>
<h3 id="const_cast"><a class="header" href="#const_cast">const_cast</a></h3>
<p>Единственный C++ каст, который умеет модифицировать cv-квалификаторы. А больше он ничего и не умеет. Зачастую нужен, чтобы просто снять <code>const</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Объявление-шаблона"><a class="header" href="#Объявление-шаблона">Объявление шаблона</a></h2>
<p>Объявление шаблонного класса или шаблонной функции в примере ниже:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct vector {
    void push_back(T const &amp;);
    T const&amp; operator[](size_t index) const;
    
    template &lt;typename U&gt;
    void g(T, U);
};

template &lt;typename T&gt;
void f(T&amp;&amp; a, T&amp;&amp; b) {
    std::cout &lt;&lt; a + b &lt;&lt; std::endl;
}
</code></pre>
<p>Вместо T и U будет подставляться тот тип, который был указан в шаблонном параметре при использовании класса/функции. Также в большинстве случаев компилятор может вывести тип самостоятельно без явного его указания.</p>
<pre><code class="language-cpp">vector&lt;int&gt; v;
vector&lt;double&gt; v2;

v.template g&lt;float&gt;(42, 42.0);
v.g(42, 42.0); // same

f(1, 3);     // 4
f(1.5, 2.5); // 4.0
</code></pre>
<h2 id="Специализации"><a class="header" href="#Специализации">Специализации</a></h2>
<p>Специализация - это выделенная реализация для каких-то указанных типов. К примеру из примера выше для <code>vector&lt;std::string&gt;</code> и <code>void f(bool&amp;&amp;, bool&amp;&amp;)</code> я бы хотел иметь другое тело функции. Это пример надуманный, конечно.</p>
<pre><code class="language-cpp">template &lt;&gt;
struct vector&lt;std::string&gt; {
    /* ... */
};

template &lt;&gt;
void f&lt;bool&gt;(bool&amp;&amp; a, bool&amp;&amp; b) {
    std::cout &lt;&lt; (a | b) &lt;&lt; std::endl;
}
</code></pre>
<p>Специализацию можно вводить не целиком, а частично, оставляя свободными другие шаблонные параметры. В качестве примера рассмотрим простенькую реализацию <code>std::conditional</code>.</p>
<pre><code class="language-cpp">template &lt;bool Cond, typename IfTrue, typename IfFalse&gt;
struct conditional;

template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;false, IfTrue1, IfFalse1&gt; { // partial specialization
    typedef IfFalse1 type;
};

template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;true, IfTrue1, IfFalse1&gt; { // partial specialization
    typedef IfTrue1 type;
};
</code></pre>
<p>Специализациям свойственен большее высокий приоритет при разрешениях перегрузок (overload resolution).</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct vector&lt;T*&gt; {
    /* ... */
}

vector&lt;foo*&gt; v; // выберется эта специализация
</code></pre>
<p>Пример неразрешимой перегрузки:</p>
<pre><code class="language-cpp">template &lt;typename U, typename V&gt;
struct mytype {};

template &lt;typename U, typename V&gt;
struct mytype&lt;U*, V&gt; {};

template &lt;typename U, typename V&gt;
struct mytype&lt;U, V*&gt; {};

mytype&lt;long*, double*&gt; f;
</code></pre>
<p>Мы получим ошибку, так как есть два равноправных кандидата. Исправить это можно определением еще одной, более подходящей специализации:</p>
<pre><code class="language-cpp">template &lt;typename U, typename V&gt;
struct mytype&lt;U*, V*&gt; {};
</code></pre>
<h2 id="Ошибка-разделения-на-объявление-и-реализацию"><a class="header" href="#Ошибка-разделения-на-объявление-и-реализацию">Ошибка разделения на объявление и реализацию</a></h2>
<p>Давайте представим, как мы могли бы писать код с шаблонными функциями, используя разделение на объявление и реализацию, как полагается.</p>
<pre><code class="language-cpp">// util.h
template &lt;typename T&gt;
void f(T&amp;, T&amp;);

// util.cpp
template &lt;typename T&gt;
void f(T&amp; a, T&amp; b) {
    std::cout &lt;&lt; a + b &lt;&lt; std::endl;
}

// main.cpp
#include &quot;util.h&quot;
int main(){
    int a, b;
    f(a, b);
}
</code></pre>
<p>Но в данном примере, к сожалению, мы получим ошибку компиляции. Так происходит, потому что генерация и подстановка кода шаблонов (инстанцирование) происходит до линковки и после компиляции каждой отдельной единицы трансляции. Компилятор, обрабатывая <code>util.cpp</code>, не знает о том, что кто-то будет вызывать <code>f(int, int)</code> в других единицах трансляции.</p>
<p>На самом деле все шаблонные функции неявно являются <code>inline</code>, поэтому их реализацию можно сразу писать в <code>.h</code> файле.</p>
<h2 id="Инстанцирование"><a class="header" href="#Инстанцирование">Инстанцирование</a></h2>
<p>В стандарте прописано, что инстанцирование происходит только когда это необходимо. При этом компилятор может делать это в конце единицы трансляции.</p>
<p>В следующем примере приводится случай, который это показывает:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct foo {
    T* a;
    void f(){
        T a;
    }
};

int main() {
    foo&lt;void&gt; a; // так скомпилируется
    a.f();       // а так нет, ошибка из-за void a
}
</code></pre>
<p>Генерация и подстановка по требованию, так сказать. С классами работает аналогично: полное тело класса не подставляется, если не требуется. Пример:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct foo {
    T a;
};

int main() {
    foo&lt;void&gt;* a; // так скомпилируется
    a-&gt;a;         // а так нет, опять ошибка из-за void a
}
</code></pre>
<h2 id="Явное-инстанцирование"><a class="header" href="#Явное-инстанцирование">Явное инстанцирование</a></h2>
<p>Пусть мы не хотим, чтобы одни и те же лишние инстанцирования были в разных единицах трансляции. Чтобы этого избежать, можно делать так:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void foo(T) {}

template void foo&lt;int&gt;(int); // генерирует тело функции в этом месте
template void foo&lt;float&gt;(float);
template void foo&lt;double&gt;(double);
</code></pre>
<h2 id="Подавление-инстанцирования"><a class="header" href="#Подавление-инстанцирования">Подавление инстанцирования</a></h2>
<p>Пусть мы знаем, что функции уже где-то инстанцированы и мы не хотим лишних:</p>
<pre><code class="language-cpp">extern template void foo&lt;int&gt;(int); 
extern template void foo&lt;float&gt;(float);
</code></pre>
<p>Выдаём тело наружу и говорим, что уже проинстанцировано. <code>main</code> не будет пытаться инстанцировать функцию, так как увидит <code>extern</code> и будет работать соответствующе.</p>
<p>Теперь зная про шаблоны и специализации можно творить всякую магию:</p>
<h2 id="Подсчет-факториала-в-compile-time"><a class="header" href="#Подсчет-факториала-в-compile-time">Подсчет факториала в compile-time</a></h2>
<p>Осторожно, при отрицательных значениях компилятор может надолго зависнуть.</p>
<pre><code class="language-cpp">template &lt;int T&gt;
struct factorial {
    static const int result = T * factorial&lt;T - 1&gt;::result;
};


template &lt;&gt;
struct factorial&lt;0&gt; {
    static const int result = 1;
};

static_assert(factorial&lt;0&gt;::result == 1);
static_assert(factorial&lt;3&gt;::result == 6);
static_assert(factorial&lt;5&gt;::result == 120);
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/11_templates.md">cpp-notes/11_templates.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parameter-pack"><a class="header" href="#parameter-pack">Parameter pack</a></h2>
<p>В следующую функцию можно передать ноль или более различных аргументов любого типа.</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    // ...
}
</code></pre>
<p>Как теперь можно работать с аргументом <code>args</code>?</p>
<p>Можно развернуть его в список аргументов другой функции, как если бы мы перечислили аргументы через запятую.</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    std::cout &lt;&lt; sum(args...);
}
</code></pre>
<p>Теперь если мы вызовем <code>f(1, 1.f, '1')</code>, то в консоль выведется результат <code>sum(1, 1.f, '1')</code>.</p>
<p>Parameter pack можно использовать и для более хитрых вещей, например, в следующем примере:</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void f(Args&amp;&amp;... args) {
    std::cout &lt;&lt; sum((args * 2)...);
}
</code></pre>
<p>Конструкция <code>((args * 2)...)</code> развернется в <code>(a1 * 2, a2 * 2, a3 * 2)</code>.</p>
<p>Раскрывать parameter pack можно с помощью, например, рекурсии:</p>
<pre><code class="language-cpp">int sum(int t) {
    return t;
}

template &lt;typename... Tail&gt;
int sum(int t, Tail... tail) {
    return t + sum(tail...);
}

template&lt;typename... Args&gt;
void f(Args... args) {
    std::cout &lt;&lt; sum(args...);
}

f(1, 2, 3); // out: 6
</code></pre>
<p>С помощью variadic templates, <code>type_traits</code> и <code>SFINAE</code> можно делать умопомрачительные вещи (в том числе в compile-time), но мы опустим этот момент.</p>
<h2 id="fold-expressions-c17"><a class="header" href="#fold-expressions-c17">Fold expressions (C++17)</a></h2>
<p>Синтаксис:</p>
<ol>
<li>( pack_name op ... )</li>
<li>( ... op pack_name )</li>
<li>( pack_name op ... op init )</li>
<li>(init op ... op pack )</li>
</ol>
<p>где pack_name - имя parameter pack, op - оператор, init - начальное значение.</p>
<p>Во что эти конструкции разворачиваются:</p>
<ol>
<li>( E op ... ) -&gt; ( E1 op (... op ( En-1 op En )))</li>
<li>( ... op E) -&gt; ((( E1 op E2 ) op ...) op En )</li>
<li>( E op ... op I ) -&gt; ( E1 op (... op ( En op I )))</li>
<li>( I op ... op E ) -&gt; ((( I op E1 ) op ...) op En )</li>
</ol>
<h3 id="Битовое-И-переменного-числа-аргументов"><a class="header" href="#Битовое-И-переменного-числа-аргументов">Битовое И переменного числа аргументов</a></h3>
<pre><code class="language-cpp">template &lt;typename... Args&gt;
bool all(Args... args) {
    return (... &amp;&amp; args);
}

static_assert(all(true, true, false) == false);
static_assert(all() == true); // ?
</code></pre>
<p>Для раскрытия parameter pack длины 0 некоторые операторы имеют значения по умолчанию:</p>
<ul>
<li>Логическое И -&gt; <code>true</code></li>
<li>Логическое ИЛИ -&gt; <code>false</code></li>
<li>Оператор запятой <code>,</code> -&gt; <code>void()</code> (?)</li>
</ul>
<h3 id="Вывод-в-консоль-переменного-числа-аргументов"><a class="header" href="#Вывод-в-консоль-переменного-числа-аргументов">Вывод в консоль переменного числа аргументов</a></h3>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void print(Args&amp;&amp;... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; '\n';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Исключения"><a class="header" href="#Исключения">Исключения</a></h2>
<p>Исключительная ситуация - следствие вызова операции с ошибкой, которая не может или не должна быть проигнорирована.</p>
<p>Например, деление на ноль вне типа <code>double</code>. К чему это должно привести? Непонятно, поэтому кидаем исключение.</p>
<p>Другой пример: <code>dynamic_cast</code> не смог привести тип к другой ссылке. Что нужно вернуть, чтобы принимающий знал, что операция завершилась неудачей? Нулевой ссылки не бывает, значит, кидаем исключение.</p>
<p>Для генерации исключения в C++ используется слово <code>throw</code>. Бросать можно практически все, что угодно (можно сказать, все, что можно сконструировать). Где будет выделена память под объект, который будем бросать - не специфицировано.</p>
<p>Для отлавливания исключений используем блоки <code>try</code> и <code>catch</code>.</p>
<pre><code class="language-cpp">struct A {};
struct B : A {};

try {
    // бросает B
    f();
    
} catch (B b) {
    // так можно
    
} catch (const B&amp; b) {
    // так можно
    
} catch (B&amp;&amp; b) {
    // ошибка компиляции

} catch (const A&amp;) {
    // так можно

} catch (A a) {
    // так можно, но осторожно

} catch (...) {
    // так можно, ловит все

}
</code></pre>
<p>Поиск обработчика при появлении исключения в блоке <code>try</code> идет последовательно, в объявленном разработчиком порядке, поэтому рекомендуется писать обработчики от частного к общему.</p>
<p>Если обработчик не был найден, исключение покинет блок <code>try</code>, и стек продолжит разворачиваться.</p>
<p>Конструкцию <code>throw</code> можно писать по-разному:</p>
<pre><code class="language-cpp">struct A {};
struct B : A {};

void f() {
    throw B();     // B
    throw new B(); // B*
}

try {
    // бросает B
    f();
    
} catch (B b) {
    throw b;
    // new B1 will be copied on catch(B b)
    // new B2 will be copied on throw
    // B2 will be thrown
    // B and B1 will be destroyed
    
} catch (B b) {
    throw;
    // new B1 will be copied on catch(B b)
    // B1 will be thrown
    // B will be destroyed
    
} catch (const B&amp; b) {
    throw b;
    // new B1 will be copied on throw
    // B1 will be thrown
    // B will be destroyed
    
} catch (const B&amp; b) {
    throw;
    // B will be thrown

} catch (const A&amp;) {
    throw;
    // B will be thrown

} catch (A a) {
    throw;
    // B will be thrown (check on gotbolt, i'm not sure)

} catch (...) {
    throw;
    // caught object will be thrown
}

</code></pre>
<h2 id="noexcept"><a class="header" href="#noexcept">noexcept</a></h2>
<p>При использовании после объявления функции ключевое слово <code>noexcept</code> разворачивается в конструкцию <code>noexcept(true)</code>, означающую &quot;эта функция никогда не бросает исключения&quot;.</p>
<p>Гарантия с нашей стороны позволяет компилятору генерировать более компактный код. Однако, если мы нарушим гарантию, и исключение будет брошено из <code>noexcept</code> функции, то мгновенно произойдет вызов <code>std::terminate</code> и по умолчанию программа аварийно завершится без запуска каких-либо деструкторов.</p>
<pre><code class="language-cpp">void f() noexcept {}

void g() noexcept {
    throw &quot;oops&quot;;
} // calls std::terminate()
</code></pre>
<p>В конструкцию <code>noexcept(expr)</code> после объявления функции можно писать любое статическое булево выражение. Таким образом гарантия исключений шаблонных функций может, например, зависеть от переданного в них типа:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void foo(T&amp;&amp; t) noexcept(std::is_trivially_destructible_v&lt;T&gt;);
</code></pre>
<p>В другом случае <code>noexcept(expr)</code> служит булевым оператором, проверяющим, является ли переданная в <code>unevaluated</code>-контексте функция <code>noexcept</code>-функцией.</p>
<pre><code class="language-cpp">struct A {
    ~A() {
        // non-trivial
    }
};

static_assert(noexcept(foo&lt;A&gt;(std::declval&lt;A&gt;())) == 0);
</code></pre>
<p>Часто используется в таком виде:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void bar(T&amp;&amp; t) noexcept(noexcept(f&lt;T&gt;(std::declval&lt;T&gt;())));
</code></pre>
<h2 id="Исключения-в-деструкторах"><a class="header" href="#Исключения-в-деструкторах">Исключения в деструкторах</a></h2>
<p>Деструкторы, начиная со стандарта C++11, неявно помечены как <code>noexcept</code>, то есть им не разрешается бросать исключения вообще, иначе произойдет мгновенный вызов <code>std::terminate</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Статическая-и-динамическая-инициализация"><a class="header" href="#Статическая-и-динамическая-инициализация">Статическая и динамическая инициализация</a></h2>
<p>Известно, как можно ускорить свою программу до предела - считать что-то нужное аж на этапе компиляции. Рассмотрим следующий пример:</p>
<pre><code class="language-cpp">int f() {
    int result;
    std::cin &gt;&gt; result;
    return result;
}

int a = 42;
int b = f();
</code></pre>
<p>Ничто не мешает переменной <code>a</code> быть подсчитанной на этапе компиляции, поскольку мы знаем, чему равно выражение справа. С другой стороны, переменная <code>b</code> не может быть посчитана на этапе компиляции по очевидным причинам - ей нужен пользовательский ввод.</p>
<p>Говорят, что переменная <code>a</code> инициализируется статически (на этапе компиляции), а переменная <code>b</code> - динамически, в runtime.</p>
<p>Динамическая инициализация глобальных переменных происходит в момент запуска программы до входа в функцию <code>main</code>, а разрушаются они после выхода из <code>main</code>, при этом имеются недостатки:</p>
<ul>
<li>При запуске программы тратится время на инициализацию</li>
<li>В одной единице трансляции переменные инициализируются сверху вниз, а между разными порядок не гарантирован. Это становится проблемой, когда инициализация переменной в одной единице трансляции обращается к переменной в другой, а та ещё не инициализирована.</li>
<li>Исключение при динамической инициализации глобальной переменной аварийно завершает программу, так как до входа в <code>main</code> его негде поймать.</li>
</ul>
<h2 id="Спецификатор-constexpr"><a class="header" href="#Спецификатор-constexpr">Спецификатор constexpr</a></h2>
<p>Спецификатор <code>constexpr</code> можно приписывать к возвращаемому типу функций, методов, а также к переменным.</p>
<pre><code class="language-cpp">constexpr T f(...) {
    /* ... */
}

constexpr T name = expr;
</code></pre>
<p>Для переменной это значит, что выражение справа обязано уметь считаться на этапе компиляции, иначе получим ошибку компиляции.</p>
<p>Для функции же это значит, что она может считаться как на этапе компиляции, так и в runtime (не будет выведена ошибка компиляции), если какой-то из переданных параметров не может быть посчитан в compile-time.</p>
<p>В <code>constexpr</code> функции нельзя использовать выражения, не являющиеся константой времени компиляции, например, использование <code>std::cin</code> или вызов не <code>constexpr</code>-функции.</p>
<p>Простой пример использования ниже:</p>
<pre><code class="language-cpp">int sum(int a, int b) {
    return a + b;
}

constexpr int c_sum(int a, int b) {
    return a + b;
}

constexpr int a1 = c_sum(5, 12); // посчитается при компиляции
constexpr int a2 = sum(5, 12);   // ошибка: sum() не является constexpr выражением
int a3 = c_sum(5, 12);           // будет посчитано в runtime
int a4 = sum(5, 12);             // так же
</code></pre>
<p>Сейчас <code>constexpr</code> позволяется очень многое, и компилятору нужно тщательно следить за тем, чтобы не допустить UB. К примеру, он подскажет о переполнении чисел во время подсчета или делении на ноль, а также о пределе вложенности вызовов.</p>
<pre><code class="language-cpp">error: constexpr variable 'foo' must be initialized by a constant expression
    constexpr int foo = 13 + 2147483647;
                  ^     ~~~~~~~~~~~~~~~
</code></pre>
<p>С++ понемногу становился интерпретируемым языком, если можно так сказать. Но сначала ограничений было много и программировать можно было только в стиле, похожем на функциональный.</p>
<p>Вот так можно было считать факториал в compile-time вместо шаблонов.</p>
<pre><code class="language-cpp">constexpr int factorial(int n) {
    return n == 0 ? 1 : n * factorial(n - 1);
}

static_assert(factorial(5) == 120);
</code></pre>
<p>Затем добавили возможность использовать константные ссылки (принимать и возвращать), <code>if</code>, <code>typedef</code>, <code>using</code> и <code>static_assert</code>:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
constexpr T self(const T&amp; a) {
    return *(&amp;a);
}

template &lt;typename T&gt;
constexpr const T&amp; self_ref(const T&amp; a) {
    return *(&amp;a);
}

constexpr auto a1 = self(123); // OK
constexpr auto a2 = self_ref(123); // OK
</code></pre>
<p>Также разрешили объявлять типы (<code>class</code>, <code>enum</code> и т.д.) и возвращать <code>void</code>, а еще создавать инстансы классов с <code>constexpr</code>-конструктором, имеющих также тривиальный деструктор.</p>
<p>Главной проблемой оставался запрет на изменение какой-либо переменной в контексте <code>constexpr</code>-функций. Таким образом мы не имели <code>for</code> и <code>while</code>. Но вскоре и это разрешили делать, но с небольшой ремаркой.</p>
<p>Изменять объект в рамках вычисления <code>constexpr</code>-выражения можно только если он был создан в процессе вычисления этого выражения:</p>
<pre><code class="language-cpp">constexpr int f(int a) {
    int n = a;
    ++n;
    return n * a;
}

int k = f(4);           // OK
                        // переменная 'n' внутри 'f' может быть
                        // модифицирована, так как она была создана
                        // во время вычисления выражения

constexpr int k2 = ++k; // ошибка.
                        // нельзя модифицировать переменную k, потому
                        // что она была создана до начала вычисления
                        // выражения
</code></pre>
<p>Позднее разрешили делать <code>constexpr</code>-лямбды.</p>
<p>Начиная с С++20 в <code>constexpr</code>-контексте можно использовать <code>std::vector</code> и некоторые его методы, например, <code>push_back</code>, <code>operator[]</code> или <code>size</code>.</p>
<p>В будущем могут разрешить и другие STL контейнеры (да прибудет с вами <code>constexpr</code>-аллокатор), но с ремаркой, что такую память нужно освобождать по завершению вычисления <code>constexpr</code>-выражения. Впрочем, есть предложения уметь не просто освобождать ее, а, например, еще возвращать (<em>non-transient constexpr allocations using propconst</em>).</p>
<p>Таким образом мы движемся к интерпретатору на уровне компилятора.</p>
<p>Бонус: подсчет факториала в compile-time с сохранением результатов для использования в runtime. Как написать это на шаблонах мне не известно.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;array&gt;

template &lt;size_t N&gt;
constexpr std::array&lt;int, N&gt; factorials() {
    std::array&lt;int, N&gt; a{1};
    for (size_t i = 1; i &lt; N; ++i) {
        a[i] = a[i - 1] * i;
    }
    return a;
}

int main() {
    constexpr auto f = factorials&lt;10&gt;();
    for (int i : f) {
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}
</code></pre>
<h2 id="Спецификатор-consteval-c20"><a class="header" href="#Спецификатор-consteval-c20">Спецификатор consteval (C++20)</a></h2>
<p>Как проверить, что значение <code>constexpr</code>-функции точно будет вычислено в compile-time?</p>
<p>Можно присвоить ее в <code>constexpr</code>-переменную, потому что, как мы знаем, выражение справа от такой переменной обязано быть <code>constexpr</code>.</p>
<p>Но есть и более прямой способ сказать, что функция может вызываться только и только на этапе компиляции. Для этого ввели спецификатор <code>consteval</code>.</p>
<pre><code class="language-cpp">consteval int sqr(int n) {
  return n*n;
}

constexpr int r = sqr(100);  // OK
int x = 100;                 // non-constexpr variable
int r2 = sqr(x);             // error: x is not usable in a constant expression
</code></pre>
<h2 id="if-constexpr-c17"><a class="header" href="#if-constexpr-c17">if constexpr (C++17)</a></h2>
<p>Позднее появился особенный вариант для <code>if</code>, который позволил разгрузить страшный шаблонный код, который пишут, используя <code>SFINAE</code>.</p>
<p>Конструкция <code>if constexpr</code> требует, чтобы проверяемое условие было <code>constexpr</code> выражением, и делает бранчинг на этапе компиляции, опуская из кода ветку, которая не подходит условию. Таким образом данный код будет компилироваться.</p>
<pre><code class="language-cpp">struct A {
    static constexpr bool has_foo = true;
    void foo();
};

struct B {
    static constexpr bool has_foo = false;
    void bar();
};

template &lt;typename T&gt;
void f(T obj) {
    if constexpr (T::has_foo) {
        obj.foo();
    } else {
        obj.bar();
    }
}
</code></pre>
<p>Очевидно, что с использованием просто <code>if</code> произойдет ошибка компиляции. Класс A не имеет метода <code>bar</code>, а класс B не имеет метода <code>foo</code>.</p>
<p>Еще раз стоит отметить, что данная конструкция не является заменой обычному <code>if</code>, она принимает только <code>constexpr</code>-выражения.</p>
<p>Пример кода, который не скомпилируется:</p>
<pre><code class="language-cpp">constexpr bool is_even(int a) {
    if constexpr (a &amp; 1) {
        return false;
    } else {
        return true;
    }
}
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://habr.com/ru/post/579490/">Дизайн и эволюция constexpr в C++ / Хабр (habr.com)</a></p>
<p><a href="https://habr.com/ru/post/228181/">Спецификатор constexpr в C++11 и в C++14 / Хабр (habr.com)</a></p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/22_constexpr.md">cpp-notes/22_constexpr.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="decltype"><a class="header" href="#decltype">decltype</a></h2>
<p>Иногда возвращаемый тип не хочется писать руками:</p>
<pre><code class="language-cpp">int f();

??? g() {
    return f();
}
</code></pre>
<p>В C++11 появилась конструкция, позволяющая по выражению узнать его тип:</p>
<pre><code class="language-cpp">int main() {
    decltype(2 + 2) a = 42; // int a = 42;
}

decltype(f()) g() {
    return f();
}
</code></pre>
<p><code>decltype</code> сделан так, чтобы его было удобно использовать для возврата значений:</p>
<pre><code class="language-cpp">int foo();
int&amp; bar();
int&amp;&amp; baz();

// decltype(foo()) -&gt; int
// decltype(bar()) -&gt; int&amp;
// decltype(baz()) -&gt; int&amp;&amp;
</code></pre>
<p>То есть <code>decltype(expr)</code> возвращает следующие типы:</p>
<ul>
<li>type для <code>prvalue</code></li>
<li>type&amp; для <code>lvalue</code></li>
<li>type&amp;&amp; для <code>xvalue</code></li>
</ul>
<p>Также ключевое слово <code>decltype</code> применимо для переменных и членов класса.</p>
<pre><code class="language-cpp">struct x {
    int a;
};

int main() {
    decltype(x::a) y; // int y

    int a;
    decltype(a) b = 42; // int b = 42
    decltype((a)) c = a; // int &amp; c = a
}
</code></pre>
<p>Последнее работает так, потому что <code>(a)</code> - это выражение, и оно имеет тип int&amp;, а <code>a</code> - это имя переменной.</p>
<h2 id="declval"><a class="header" href="#declval">declval</a></h2>
<p>Иногда хочется узнать тип чего-то, что зависит от шаблонных аргументов функции, но просто сделать это с помощью <code>decltype</code> не получится, так как тогда компилятор встречает обращение к параметру функции, когда еще не дошел до его объявления.</p>
<p>Для этого есть синтаксическая конструкция <code>declval</code>:</p>
<pre><code class="language-cpp">int foo(int);
float foo(float);

// compile error
template &lt;typename T&gt;
decltype(foo(t)) f(T&amp;&amp; t) {
    return foo(std::forward&lt;T&gt;(t));
}

// nice.
template &lt;typename T&gt;
decltype(foo(declval&lt;T&gt;())) f(T&amp;&amp; t) {
    return foo(std::forward&lt;T&gt;(t));
}
</code></pre>
<p>Сигнатура <code>declval</code> могла бы выглядеть как-то так:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T declval();
</code></pre>
<p>Для <code>declval</code> не нужно тело функции, так как <code>decltype</code> не генерирует машинный код и считается на этапе компиляции.</p>
<p>В языке есть несколько мест с похожей логикой - например, <code>sizeof</code>. Такие места называются <em>unevaluated contexts</em>.</p>
<p>При использовании сигнатуры, как выше, могут возникать проблемы с неполными типами (просто не скомпилируется). Это происходит из-за того, что если функция возвращает структуру, то в точке, где вызывается функция, эта структура должно быть complete типом. Чтобы обойти это, делают возвращаемый тип rvalue-ссылкой:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; declval();
</code></pre>
<h3 id="trailing-return-types"><a class="header" href="#trailing-return-types">Trailing return types</a></h3>
<p>Чтобы не писать <code>declval</code>, сделали возможной следующую конструкцию:</p>
<pre><code class="language-cpp">template &lt;typename... Args&gt;
auto f(Args&amp;&amp;... args) -&gt; decltype(foo(std::forward&lt;Args&gt;(args)...)) {
    return foo(std::forward&lt;Args&gt;(args)...);
}
</code></pre>
<p>То есть компилятор, натыкаясь на <code>decltype</code> уже знает аргументы, которые передаются в функцию, и может на них опираться. <em>Очень удобно, конечно (сарказм).</em></p>
<h2 id="auto"><a class="header" href="#auto">auto</a></h2>
<p>Можно заметить, что в <code>return</code> и <code>decltype</code> повторяется одно и то же выражение. Во избежание копипасты добавили возможность писать <code>decltype(auto)</code>.</p>
<pre><code class="language-cpp">int main() {
    decltype(auto) b = 2 + 2; // int b = 2 + 2;
}

template &lt;typename... Args&gt;
decltype(auto) f(Args&amp;&amp;... args) {
    return foo(std::forward&lt;Args&gt;(args)...);
}
</code></pre>
<p>Возникает вопрос, а зачем нам вообще <code>decltype</code>, можно ли заменить его на просто <code>auto</code>? Для этого стоит сказать о том, как работает <code>auto</code>.</p>
<p>Правило вывода типов у <code>auto</code> почти полностью совпадает с тем, как выводятся шаблонные параметры. Поэтому <code>auto</code> отбрасывает ссылки и cv-квалификаторы.</p>
<pre><code class="language-cpp">int&amp; bar();

int main() {
    auto c = bar(); // int c = bar()
    auto&amp; c = bar(); // int&amp; c = bar()
}
</code></pre>
<p>Поэтому обычный <code>auto</code> в возвращаемом типе отбрасывает ссылки с cv-квалификаторами, поэтому чаще всего нам нужен именно <code>decltype(auto)</code>.</p>
<p>Еще стоит сказать, что если у функции несколько инструкций <code>return</code>, который выводятся в разные типы, то использовать <code>decltype</code> и <code>auto</code> нельзя:</p>
<pre><code class="language-cpp">// compile error
auto f(bool flag) {
    if (flag) {
        return 1;
    } else {
        return 1u;
    }
}
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/18_decltype_auto_nullptr.md">cpp-notes/18_decltype_auto_nullptr.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sfinae"><a class="header" href="#sfinae">SFINAE</a></h2>
<p>SFINAE - substitution failed is not an error. Для того, чтобы сказать, что это такое, необходимо вспомнить, как разрешаются перегрузки функций.</p>
<pre><code class="language-cpp">void f(int, std::vector&lt;int&gt;);
void f(int, int);
void f(double, double);
void f(int, int, char, std::string, std::vector&lt;int&gt;);
void f(std::string);

f(1, 2);
</code></pre>
<ol>
<li>Для сопоставления <code>f(1, 2)</code> с конкретной функцией компилятор отправит все функции с названием <code>f</code> в overload resolution.</li>
<li>Далее из списка исчезают кандидаты, у которых количество параметров не может совпасть с теми, что представлены в вызове.</li>
<li>Потом отсекаются функции, типы параметров которых отличаются от переданных аргументов и для которых нет неявного преобразования.</li>
<li>После этого идут несложные, но многословные правила поиска лучшей перегрузки, и побеждает <code>f(int, int)</code>, так как она не требует преобразований аргументов.</li>
</ol>
<p>Если бы обе подходили одинаково хорошо, то вызов был бы двусмысленным, о чём компилятор сообщил бы. Так, в общих чертах, и работает перегрузка методов в C++.</p>
<h3 id="Добавим-шаблонные-функции"><a class="header" href="#Добавим-шаблонные-функции">Добавим шаблонные функции!</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
void function(T, T);
</code></pre>
<p>Теперь несколько изменится первая стадия:</p>
<p>Если компилятор встречает шаблонную функцию, имя которой совпадает с именем вызова, тогда он пытается вывести <em>аргументы шаблона</em>, на основании аргументов переданных в вызов (<code>argument deduction</code>).</p>
<p>И если все аргументы удаётся вывести, то шаблонная функция с выведенными аргументами добавляется в список кандидатов функций.</p>
<p>В нашем примере в конце все равно останется только нешаблонная <code>f(int, int)</code>, так как при прочих равных нешаблонная функция всегда сильнее шаблонной.</p>
<p>А что происходит, если вывести аргументы шаблона не удалось? Тогда такая шаблонная функция просто не попадает в список overload resolution. Это и есть правило <code>SFINAE</code>. Но следует понимать, что рассматривается <strong>исключительно</strong> сигнатура функции и ничего больше.</p>
<p>Поэтому если подстановка аргументов даёт корректную функцию с точки зрения её сигнатуры, и функция побеждает в перегрузке, а потом оказывается, что в теле функции есть какие-то проблемы, с которыми компилятор справится не может, то компиляция будет завершена ошибкой - это называется <code>hard error</code>.</p>
<h2 id="Примитивное-sfinae"><a class="header" href="#Примитивное-sfinae">Примитивное SFINAE</a></h2>
<p>Используя SFINAE мы можем получить рефлексию на этапе компиляции, узнавая свойства объектов, и в зависимости от этого разрешать или запрещать им использовать какие-то функции и прочее.</p>
<p>Следующая шаблонная шапка позволяет использовать функцию после нее только с типами, в которых объявлен тип с алиасом <code>iterator</code>. Если такого алиаса в типе объявлено не будет, то произойдет ошибка вывода шаблонных аргументов и данная функция не попадет в список overload resolution.</p>
<pre><code class="language-cpp">template &lt;typename T, typename = typename T::iterator&gt;
</code></pre>
<p>Подобным образом в шаблонных параметрах можно объявлять и другие ограничения на используемые шаблонные типы.</p>
<h2 id="О-сигнатуре-шаблонной-функции"><a class="header" href="#О-сигнатуре-шаблонной-функции">О сигнатуре шаблонной функции</a></h2>
<p>Многим известно, что возвращаемый тип в функции не является частью её сигнатуры, но это не так для шаблонных функций. Это позволяет использовать, например, <code>std::enable_if</code> на возвращаемом типе.</p>
<p>Схематично, это выглядит так:</p>
<pre><code class="language-cpp">template &lt;bool condition, class T = void&gt;
struct enable_if;

template&lt;class T&gt;
struct enable_if&lt;true, T&gt; {
    typedef T type;
};
</code></pre>
<p>То есть, при передаче в шаблон <code>true</code> в структуре появляется поле <code>type</code> по умолчанию типа <code>void</code>, но если шаблон был вызван с параметром <code>false</code>, то этого поля не будет, а его использование в сигнатуре функции или в шапке шаблона приведет к неудаче вывода, и эта перегрузка не будет включена в список кандидатов.</p>
<p>Напишем надуманный пример, использующий <code>enable_if</code> в возвращаемом типе.</p>
<pre><code class="language-cpp">namespace {
    struct tag;
}

template &lt;typename T&gt;
enable_if&lt;std::is_trivially_destructible_v&lt;T&gt;&gt;::type f(T);

template &lt;typename T&gt;
enable_if&lt;!std::is_trivially_destructible_v&lt;T&gt;, tag&gt;::type f(T);

template &lt;typename T&gt;
constexpr bool is_void_f = std::is_same_v&lt;decltype(f(std::declval&lt;T&gt;())), void&gt;;

int main() {
    std::cout &lt;&lt; is_void_f&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_void_f&lt;std::string&gt; &lt;&lt; std::endl;
} // output: 1 0
</code></pre>
<h2 id="Применение-sfinae-в-бою"><a class="header" href="#Применение-sfinae-в-бою">Применение SFINAE в бою</a></h2>
<p>В заметке про <code>if constexpr</code> написан пример, позволяющий по члену класса <code>has_foo</code> судить о наличии соответствующего метода в классе. Попробуем написать метафункцию, определяющую существование в классе, например, метода <code>void foo(int)</code> с помощью новых знаний.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
    static constexpr bool value = true; // сейчас придумаем, что здесь написать
};
</code></pre>
<p>Осталось придумать перегрузку, определяющие нужные нам свойства типа, и как получить из нее булевскую константу.</p>
<p>Во-первых создадим всеядную функцию-подложку (иногда говорят, fallback), которую компилятор выберет, если не подойдет полезная перегрузка, присваивающая каким-то образом в <code>value</code> значение <code>true</code>.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
    struct dummy;
    static dummy detect(...); // fallback
    static constexpr bool value = true;  // ладно-ладно, уже скоро придумаем!
};
</code></pre>
<p>Теперь придумаем детектор. Здесь нам придется воспользоваться конструкциями <code>decltype</code> и <code>std::declval</code>, которые могут вызываться на этапе компиляции и проверять свойства без реальных вызовов конструкторов, функций и прочего.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
    struct dummy;
    static dummy detect(...); // fallback
    
    template&lt;typename U&gt;
    static decltype(std::declval&lt;U&gt;().foo(42)) detect(const U&amp;); // detector
    
    static constexpr bool value = true;  // теперь точно скоро!
};
</code></pre>
<p>Теперь осталось воспользоваться детектором, чтобы поставить правильное значение поля <code>value</code>. Также упростим синтаксис для конечного пользователя.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct has_foo {
private:  // скроем детали реализации
    struct dummy;
    static dummy detect(...);
    
    template&lt;typename U&gt;
    static decltype(std::declval&lt;U&gt;().foo(42)) detect(const U&amp;);
    
public:
    static constexpr bool value =
        std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value;
};

template &lt;typename T&gt;
constexpr bool has_foo_v = has_foo&lt;T&gt;::value;
</code></pre>
<p>Использование:</p>
<pre><code class="language-cpp">struct check1 {
    void foo(int);
};

struct check2 {};

int main() {
    std::cout &lt;&lt; has_foo_v&lt;check1&gt; &lt;&lt; std::endl; // 1
    std::cout &lt;&lt; has_foo_v&lt;check2&gt; &lt;&lt; std::endl; // 0
    // или
    std::cout &lt;&lt; has_foo&lt;check1&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; has_foo&lt;check2&gt;::value &lt;&lt; std::endl;
}
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="http://scrutator.me/post/2016/12/12/sfinae.aspx">SFINAE. Как много в этом слове (scrutator.me)</a></p>
<p><a href="https://habr.com/ru/post/205772/">SFINAE — это просто / Хабр (habr.com)</a></p>
<p><a href="https://ru.wikipedia.org/wiki/SFINAE">SFINAE — Википедия (wikipedia.org)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Что-такое-raii"><a class="header" href="#Что-такое-raii">Что такое RAII</a></h2>
<p>RAII (Resource Acquisition Is Initialization) значит, что при получении какого-либо ресурса, его инициализируют в конструкторе, а, поработав с ним в функции - корректно освобождают в деструкторе. Даже если в коде бросится исключение, то RAII-объект должен корректно уничтожить принадлежащий ему объект.</p>
<p>Существует три типа гарантии безопасности исключений:</p>
<ol>
<li>Базовая гарантия - при возникновении любого исключения в некотором методе, состояние программы должно оставаться согласованным. Это означает, не только отсутствие утечек ресурсов, но и сохранение инвариантов класса.</li>
<li>Строгая гарантия - если при выполнении операции возникает исключение, то это не должно оказать какого-либо влияния на состояние приложения. Другими словами, строгая гарантия исключений обеспечивает транзакционность операций.</li>
<li>Гарантия отсутствия исключений - ни при каких обстоятельствах функция не будет генерировать исключения.</li>
</ol>
<h2 id="stdshared_ptr"><a class="header" href="#stdshared_ptr">std::shared_ptr</a></h2>
<p>Осуществляет подсчет ссылок. Когда количество ссылок обнулится, хранимый объект уничтожится с помощью <code>delete</code>, <code>delete[]</code> или переданного в конструкторе <code>deleter</code>'а.</p>
<p>Копируемый. Потокобезопасный на методы своего класса при вызовах к разным экземплярам <code>shared_ptr</code> (отсюда следует, что счетчик ссылок атомарен), но может случиться data race при доступе к одному и тому же экземпляру <code>shared_ptr</code>.</p>
<p>Из-за того, что каждое копирование <code>shared_ptr</code> - дорогое удовольствие, лучше пользоваться его передачей по ссылке, где это возможно.</p>
<p>В конструкторе тип данных передаваемого указателя должен быть complete-типом.</p>
<p>Частая ошибка:</p>
<pre><code class="language-cpp">T *p = new T();
std::shared_ptr&lt;T&gt; p1(p);
std::shared_ptr&lt;T&gt; p2(p);
</code></pre>
<p>Такой код некорректен, так как у <code>p1</code> и <code>p2</code> разные счётчики ссылок, поэтому объект <code>*p</code> удалится дважды. Чтобы этого не происходило, не нужно оборачивать один сырой указатель в <code>shared_ptr</code> дважды - есть конструкторы копирования.</p>
<h3 id="aliasing-constructor"><a class="header" href="#aliasing-constructor">Aliasing constructor</a></h3>
<p>Иногда возникает желание ссылаться с помощью <code>shared_ptr</code> на объект и его мемберов. Наивное решение:</p>
<pre><code class="language-cpp">struct wheel {};
struct vehicle {
    std::array&lt;std::shared_ptr&lt;wheel&gt;, 4&gt; wheels;
};
</code></pre>
<p>Проблема такого подхода в том, что при удалении <code>vehicle</code>, <code>wheel</code> остаются живы, пока на них кто-то ссылается.</p>
<p>Можем захотеть такое поведение: пока кто-то ссылается на составную часть объекта, основной объект жив. Для этого можно использовать для них общий счётчик ссылок.</p>
<pre><code class="language-cpp">struct wheel {};
struct vehicle {
    std::array&lt;wheel, 4&gt; wheels;
};

void foo() {
    std::shared_ptr&lt;vehicle&gt; v(new vehicle());
    std::shared_ptr&lt;std::array&lt;wheel, 4&gt;&gt; w(v, &amp;v-&gt;wheels);

    store_for_later(w);
} // vehicle is still alive
</code></pre>
<p>В таком случае оба указателя отвечают за удаление объекта <code>vehicle</code> (в зависимости от того, какой из указателей будет разрушен раньше), поэтому <code>deleter</code> у них общий, кроме того в управляющем блоке хранится указатель на исходный объект, чтобы передать его в <code>deleter</code>.</p>
<h3 id="stdmake_shared---зачем"><a class="header" href="#stdmake_shared---зачем">std::make_shared - зачем?</a></h3>
<p>Потенциально одна аллокация вместо двух + cache-friendly - <code>control block</code> и объект, которым владеем, лежат в одном куске памяти.</p>
<p>Кроме экономии аллокаций, <code>make_shared</code> избавляет нас от необходимости следить за исключениями в <code>new</code>. Пример кода:</p>
<pre><code class="language-cpp">bar(std::shared_ptr&lt;mytype&gt;(new mytype(1, 2, 3)),
    std::shared_ptr&lt;mytype&gt;(new mytype(4, 5, 6)));
</code></pre>
<p>Так как порядок выполнения не задан, сначала может вызваться первый <code>new</code>, затем второй, а потом только конструкторы <code>shared_ptr</code>. В таком случае, если второй <code>new</code> кинет исключение, то первый объект не удалится. <code>make_shared</code> позволяет избежать этой ошибки.</p>
<h3 id="stdenable_shared_from_this---зачем"><a class="header" href="#stdenable_shared_from_this---зачем">std::enable_shared_from_this - зачем?</a></h3>
<p>Мы уже сказали, что следующий код некорректен:</p>
<pre><code class="language-cpp">T *p = new T();
std::shared_ptr&lt;T&gt; p1(p);
std::shared_ptr&lt;T&gt; p2(p);
</code></pre>
<p>Точно такой же ошибкой, но в другой обертке, может стать и возврат из метода класса <code>shared_ptr(this)</code>, если текущий объект уже находится под наблюдением <code>shared_ptr</code>.</p>
<p>Пример хорошего и плохого кода:</p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

struct Good : std::enable_shared_from_this&lt;Good&gt; {
    std::shared_ptr&lt;Good&gt; getptr() {
        return shared_from_this();
    }
};

struct Bad {
    std::shared_ptr&lt;Bad&gt; getptr() {
        return std::shared_ptr&lt;Bad&gt;(this);
    }
    ~Bad() {
        std::cout &lt;&lt; &quot;Bad::~Bad() called\n&quot;;
    }
};

int main() {
    // Good: the two shared_ptr's share the same object
    std::shared_ptr&lt;Good&gt; gp1(new Good);
    std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;getptr();
 
    // Bad, each shared_ptr thinks it's the only owner of the object
    std::shared_ptr&lt;Bad&gt; bp1(new Bad);
    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();
} // UB: double-delete of Bad
</code></pre>
<h2 id="stdweak_ptr"><a class="header" href="#stdweak_ptr">std::weak_ptr</a></h2>
<p>Этот умный указатель ходит в паре с <code>shared_ptr</code> и может ссылаться только на объекты, которые захвачены каким-либо <code>shared_ptr</code>.</p>
<p>Отсюда способ его получения - либо конструкторы от других <code>weak_ptr</code>, либо конструктор от <code>shared_ptr</code>.</p>
<p>Сами по себе <code>weak_ptr</code> не влияют на счетчик, который ведут <code>shared_ptr</code>, от которого зависит время жизни захваченного во владение объекта, однако счетчик слабых ссылок существует все равно, поскольку необходимо знать, когда нужно удалять <code>control block</code>.</p>
<p>Имея экземпляр <code>weak_ptr</code> можно получить <code>shared_ptr</code> на ссылаемый объект с помощью метода <code>weak_ptr::lock()</code>, который вернет экземпляр <code>shared_ptr</code>, который ссылается на исходный объект (сделав +1 к счетчику, разумеется), если количество &quot;сильных&quot; ссылок еще не обнулено, и объект не удален, либо вернет пустой <code>shared_ptr</code>.</p>
<p>Данный указатель является потокобезопасным в том же смысле, как <code>shared_ptr</code>.</p>
<p>Использование <code>weak_ptr</code> необходимо, в частности, чтобы иметь два объекта, ссылающихся на друг друга умными указателями, но при этом не вызывающих утечку памяти.</p>
<h2 id="Приведение-shared_ptr-к-указателям-другого-типа"><a class="header" href="#Приведение-shared_ptr-к-указателям-другого-типа">Приведение shared_ptr к указателям другого типа</a></h2>
<p>В стандартной библиотеке реализованы все 4 вида кастов (<code>static</code>, <code>dynamic</code>, <code>const</code>, <code>reinterpret</code>) для <code>shared_ptr</code> - они создают новый инстанс <code>shared_ptr</code>, который хранит указатель, приведённый соответствующим кастом, и разделяет владение (счётчик ссылок) с исходным <code>shared_ptr</code> (привет, aliasing constructor).</p>
<p>Внутри это выглядит так, на примере <code>static_cast</code>:</p>
<pre><code class="language-cpp">template &lt;class T, class U&gt; 
std::shared_ptr&lt;T&gt; static_pointer_cast(const std::shared_ptr&lt;U&gt;&amp; r) noexcept {
    auto p = static_cast&lt;typename std::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());
    return std::shared_ptr&lt;T&gt;(r, p);
}
</code></pre>
<p><code>dynamic_cast</code> выглядит немного иначе - в случае &quot;неудачного каста&quot; (который возвращает <code>nullptr</code>) вернется пустой <code>shared_ptr</code>.</p>
<h2 id="stdunique_ptr"><a class="header" href="#stdunique_ptr">std::unique_ptr</a></h2>
<p>До внедрения в стандарт move-семантики (до С++11) разработчики могли хотеть в языке указатель, следовавший концепции RAII, но не разделяющий владение. Так появился <code>auto_ptr</code>.</p>
<p>С приходом C++11 его пришлось пометить как <code>deprecated</code>, поскольку его оператор присваивания работал ровным счетом как оператор перемещения сейчас, что могло приводить к непониманию и абсолютно не вписывалось в новые фишки стандарта. Так появился <code>unique_ptr</code>.</p>
<p><code>unique_ptr</code> не хранит счетчик ссылок (а является полным владельцем переданного ему указателя), конструктор копирования и оператор присваивания у него запрещены, зато его можно мувать.</p>
<p>В отличие от <code>shared_ptr</code> этому умному указателю не нужны дополнительные функции для кастования (опять же, потому что он является полным владельцем своего объекта), но ему так же можно настраивать <code>deleter</code> и вызывать функцию <code>make_unique()</code>, подобную таковой у первого указателя.</p>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/16_smart_pointers.md">cpp-notes/16_smart_pointers.md at master · lejabque/cpp-notes (github.com)</a></p>
<p><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this - cppreference.com</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="empty-base-optimization"><a class="header" href="#empty-base-optimization">Empty base optimization</a></h2>
<p>Разрешает классу-предку иметь нулевой размер в байтовом представлении объекта.</p>
<pre><code class="language-cpp">struct empty {};

struct derived : empty {
    int data;
};

static_assert(sizeof(empty) &gt; 0); 
static_assert(sizeof(derived) == sizeof(int));
</code></pre>
<p>В примере выше объект <code>derived</code> будет иметь одинаковый адрес со своим предком.</p>
<p>Можно подумать, что для полей, состоящих пустого класса (как <code>empty</code>) такая оптимизация тоже справедлива, но как бы не так.</p>
<pre><code class="language-cpp">struct derived {
    empty e;
    int data;
};

static_assert(sizeof(derived) == sizeof(int)); // compile error
</code></pre>
<p>Однако если класс действительно пустой, то его можно лишить своего адреса легально с помощью атрибута <code>[[no_unique_address]]</code>. В случае, если класс пустым не был, этот атрибут будет проигнорирован.</p>
<pre><code class="language-cpp">struct derived {
    [[no_unique_address]] empty e;
    int data;
};

static_assert(sizeof(derived) == sizeof(int)); // OK!
</code></pre>
<h2 id="return-value-optimization"><a class="header" href="#return-value-optimization">Return value optimization</a></h2>
<p>Нельзя опираться на то, что у возвращаемого по значению объекта будут вызваны конструкторы копирования, перемещения и/или деструктор, если он конструируется при вызове <code>return</code>. Более того, они могут даже не понадобиться при компиляции.</p>
<pre><code class="language-cpp">mytype f() {
    return mytype(1, 2, 3);
}

// компилится во что-то, похожее на:
void f(void* result) {
    mytype_ctor(result, 1, 2, 3);
}
</code></pre>
<p>Если из функции возвращается <code>prvalue</code>, то копия не создаётся и объект конструируется уже на месте - там, куда возвращается значение. Данная оптимизация записана в стандарте С++17 как <code>Copy elision</code> и обязательна для компилятора.</p>
<h2 id="named-return-value-optimization"><a class="header" href="#named-return-value-optimization">Named return value optimization</a></h2>
<p>Можно пойти дальше и ввести подобную оптимизацию для <code>lvalue</code>. На данный момент она необязательна для компиляторов. Пример:</p>
<pre><code class="language-cpp">std::string f() {
    std::string tmp;
    for (;;) {
        tmp += ...;
    }
    return tmp;
}

// можно разместить tmp уже на result-е, псевдокод:
void f(void* result) {
    string_ctor(result);
    for (;;) {
        *result += ...;
    }
}
</code></pre>
<p>Иногда <code>NRVO</code> не может быть применено, когда мы не знаем, что должно возвращаться:</p>
<pre><code class="language-cpp">std::string g() {
    std::string a(&quot;abc&quot;);
    std::string b(&quot;def&quot;);
    if (flag) {
        return a;
    } else {
        return b;
    }
}
</code></pre>
<p>Гарантированно нельзя использовать <code>NRVO</code> в <code>constexpr</code>-функциях и при инициализации глобальных, статических и thread-local переменных. Также <code>NRVO</code> неприменимо с <code>volatile</code>-объектами.</p>
<pre><code class="language-cpp">struct E {
    constexpr E() = default;
    E(const E&amp;) = delete;
    //E(E&amp;&amp;) = default; &lt;-- uncomment to fix
};

constexpr E f() {
    E e;
    return e; // compile-error: E(const E&amp;) deleted
}

E e = f();
</code></pre>
<h2 id="profile-guided-optimization"><a class="header" href="#profile-guided-optimization">Profile-guided optimization</a></h2>
<p>В отличии от методов оптимизации, основанных исключительно на анализе исходного кода, позволяет использовать трассировку работы программы, собранной со специальным флагом, на основании которой компилятором принимается решение об оптимизации тех частей кода, которые вызывались чаще всего.</p>
<p>Крайне важно запускать программу с PGO на тех данных, с которыми ваша программа будет работать в реальном мире, иначе итоговая производительность может даже уменьшиться.</p>
<p>PGO может использовать следующие оптимизации:</p>
<ul>
<li>Inlining</li>
<li>Virtual Call Suspection - условно-прямой (по условию) вызов определенной виртуальной функции в обход таблицы виртуальных функций</li>
<li>Register Allocation - оптимизация распределения данных в регистрах</li>
<li>Basic Block Optimization - помещать совместно вызываемые блоки кода в общую страницу памяти</li>
</ul>
<p>И так далее, лучше глянуть официальную документацию.</p>
<p>После запуска программы со сбором статистики необходимо скомпилировать программу еще раз уже с учетом этой статистики.</p>
<h2 id="link-time-optimization"><a class="header" href="#link-time-optimization">Link-time optimization</a></h2>
<p>LTO значит, что оптимизация будет происходить на этапе линковки.</p>
<p>Некоторые компиляторы (например, Clang) не переводят исходный код напрямую в ассемблер, а используют так называемый бэкенд, например, LLVM. Тогда при компиляции код сначала будет переводиться в байткод LLVM IR.</p>
<p>Компилятор LLVM будет оптимизировать полученный байткод во время встраивания кода функций в итоговый бинарник, и за счет снижения уровня абстракций у него это может получиться гораздо лучше, чем у компилятора на своем &quot;верхнем&quot; уровне (например, GCC).</p>
<p>Однако LTO в деле требует мощного компьютера при сборке проекта (в основном требуется больше оперативной памяти).</p>
<p>Из плюшек разделения процесса компиляции на фронтенд и бэкенд стоит отметить более лучшую переносимость кода. А в случае в LLVM, который используется уже очень много где, появляется еще одна фишка - LTO может работать при компиляции кода в единый бинарник, написанного на разных языках.</p>
<hr />
<p>Заимствования:</p>
<p><a href="https://habr.com/ru/company/vk/blog/666330/">RVO и NRVO в C++17 / Хабр (habr.com)</a></p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/14_move_rvalue.md">cpp-notes/14_move_rvalue.md at master · lejabque/cpp-notes (github.com)</a></p>
<p><a href="https://ru.wikipedia.org/wiki/LLVM">LLVM — Википедия (wikipedia.org)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Лямбда-функция"><a class="header" href="#Лямбда-функция">Лямбда-функция</a></h2>
<p>Имеет следующий синтаксис:</p>
<pre><code class="language-cpp">auto lambda = [](int a, int b) {return a &lt; b;}
</code></pre>
<p>Полученный объект по сути является структурой с известным только компилятору уникальным типом, имеющим <code>operator()</code> с аргументами, которые передаются в лямбду.</p>
<p>Возвращаемый тип можно задать явно через trailing return types, либо довериться компилятору (равносильно типу auto).</p>
<p>Квадратные скобки здесь не просто для красоты - они используются для захвата переменных из контекста объявления лямбда-функции:</p>
<pre><code class="language-cpp">int a = 42;

// захват переменной по значению
auto mul = [a](int k) {return k * a;}

// захват переменной по ссылке
auto add = [&amp;a](int k) {return k + a;}

// захват переменной по значению с присвоением нового имени (C++14)
auto sub = [b = a](int k) {return k - b;}

// захват переменной по ссылке с присвоением нового имени (C++14)
auto div = [&amp;b = a](int k) {return k / b;}
</code></pre>
<p>Также лямбды умеют делать захват всего контекста по значению или ссылке:</p>
<pre><code class="language-cpp">int x, y;

[=](){}    // все по значению
[=, &amp;x](){} // все по значению, x - по ссылке

[&amp;](){}    // все по ссылке
[&amp;, x](){} // все по ссылке, x - по значению
</code></pre>
<p>Захваченные по значению объекты являются константными, если лямбда-функция не имеет спецификатора <code>mutable</code>. Также можно захватывать <code>this</code>, как указатель на объект, где лямбда была объявлена, а можно захватывать <code>*this</code>, как копию объекта.</p>
<h3 id="Свойства-лямбд"><a class="header" href="#Свойства-лямбд">Свойства лямбд</a></h3>
<ul>
<li>могут копироваться и перемещаться</li>
<li>не могут присваиваться</li>
<li>лямбды без захвата могут конвертиться к указателю на функцию</li>
<li>при копировании лямбды копируются все захваченные по значению переменные</li>
<li>захват по ссылке не продлевает время жизни объектов. Такой код работает неправильно:</li>
</ul>
<pre><code class="language-cpp">auto foo() {
    std::vector&lt;int&gt; v;
    return [&amp;v]() {
        // ...
    };
} // v уничтожится при выходе из функции, обращение внутри лямбды - UB
</code></pre>
<p>Начиная с C++20 лямбды могут иметь шаблонные параметры:</p>
<pre><code class="language-cpp">int main() {
    auto less = []&lt;typename T&gt;(T a, T b) {return a &lt; b;};
    bool val = less(42, 43);
}
</code></pre>
<h3 id="Рекурсивный-вызов-лямбды"><a class="header" href="#Рекурсивный-вызов-лямбды">Рекурсивный вызов лямбды</a></h3>
<p>Пример ниже выдаст ошибку компиляции:</p>
<pre><code class="language-cpp">auto factorial = [&amp;factorial](int n) {
    return n &lt;= 1 ? 1 : n * factorial(n - 1);
};

</code></pre>
<p><code>error: use of 'factorial' before deduction of 'auto'</code>, что говорит нам о том, что тип <code>auto</code> еще не был выведен, поэтому пользоваться им нельзя.</p>
<h4 id="Вариант-1"><a class="header" href="#Вариант-1">Вариант 1</a></h4>
<pre><code class="language-cpp">std::function&lt;int(int)&gt; factorial;

factorial = [&amp;](int n) {
    return n &lt;= 1 ? 1 : n * factorial(n - 1);
};

std::cout &lt;&lt; factorial(4);
</code></pre>
<h4 id="Вариант-2"><a class="header" href="#Вариант-2">Вариант 2</a></h4>
<pre><code class="language-cpp">auto factorial = [](int n, auto&amp;&amp; f) -&gt; int {
    return (n &lt;= 1 ? 1 : n * f(n - 1, f));
};

std::cout &lt;&lt; factorial(4, factorial);
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/19_lambdas_type_erasure.md">cpp-notes/19_lambdas_type_erasure.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdfunction"><a class="header" href="#stdfunction">std::function</a></h2>
<p>Пусть <code>void(int,int)</code> - это тип функции, принимающей два инта и возвращающей ничего, тогда мы можем похранить ее в <code>std::function</code> следующим образом.</p>
<pre><code class="language-cpp">void print(int a, int b) {
    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
}

std::function&lt;void(int, int)&gt; func = print;

func(1, 2); // output: 1 2
</code></pre>
<p>Похранить функции с другой сигнатурой мы тоже, конечно, можем.</p>
<p>С помощью <code>function</code> мы так же можем хранить и лямбды (и любой другой функциональный объект).</p>
<pre><code class="language-cpp">void f(bool flag) {
    std::function&lt;void(int,int)&gt; func;
    if (flag) {
        func = [](int a, int b){}; 
    } else {
        // note: все лямбды имеют разный тип
        func = [](int a, int b){};
    }
}
</code></pre>
<p>Примечательно, что классу <code>function</code> достаточно знать только тип функции и только на этапе объявления объекта.</p>
<p>Этот класс реализует паттерн <code>type erasure</code>. Тот же самый паттерн встречается и в других классах STL.</p>
<h2 id="stdoptional"><a class="header" href="#stdoptional">std::optional</a></h2>
<p>Класс, который хранит опциональное значение (либо шаблонный тип, либо <code>std::nullopt_t</code>).</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; convert(std::function&lt;void(int)&gt; &amp;f) {
    // ....
    if (!fail) {
        return result;
    }
    return {};
}

int main() {
    auto val = convert(...);
    if (val.has_value()) {
        std::cout &lt;&lt; &quot;OK&quot;;
    } else {
        std::cout &lt;&lt; &quot;Fail&quot;;
    }
}
</code></pre>
<h2 id="stdany"><a class="header" href="#stdany">std::any</a></h2>
<p>Тип <code>any</code> хранит в себе объект любого типа. Так одна и та же переменная типа <code>any</code> может сначала хранить <code>int</code>, затем <code>float</code>, а затем строку.</p>
<p>Требуется каст для обратного преобразования.</p>
<pre><code class="language-cpp">std::any a = 42;
int v = std::any_cast&lt;int&amp;&gt;(a);

a = std::string(&quot;hello&quot;);
std::string s = std::any_cast&lt;std::string&amp;&gt;(a);

// a = mytype(); и так далее
</code></pre>
<p>Если в качестве шаблонного параметра <code>any_cast</code> был передан любой тип, отличный от типа текущего хранимого объекта, будет выброшено исключение <code>bad_any_cast</code>.</p>
<p>Если экземпляр <code>any</code> разрушается деструктором, то он корректно удаляет хранимый объект.</p>
<h2 id="stdvariant"><a class="header" href="#stdvariant">std::variant</a></h2>
<p>Шаблонный класс, который представляет собой типобезопасный <code>union</code>, который помнит, какой тип он хранит. В отличие от <code>union</code> , <code>variant</code> позволяет хранить не только POD-типы (тривиальные типы или тривиальные классы).</p>
<pre><code class="language-cpp">std::variant&lt;int, float, char&gt; v;

v = 3.14f;
v = 42;

std::cout &lt;&lt; std::get&lt;int&gt;(v);
</code></pre>
<p>Для получения значений из <code>variant</code> используется функция <code>get</code>. Она выбросит исключение <code>bad_variant_access</code>, если попытаться взять не тот тип.</p>
<p>Говоря про доступ к варианту, нельзя не упомянуть <code>visit</code>, принимающий функцию, которая должна уметь принимать любой тип из данного <code>variant</code>.</p>
<pre><code class="language-cpp">std::variant&lt;int, float, char&gt; v;
v = 42;

std::visit([](auto&amp; arg) {
    using Type = std::decay_t&lt;decltype(arg)&gt;;

    if constexpr (std::is_same_v&lt;Type, int&gt;) {
        std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; arg;

    } else if constexpr (std::is_same_v&lt;Type, float&gt;) {
        std::cout &lt;&lt; &quot;float: &quot; &lt;&lt; arg;

    } else if constexpr (std::is_same_v&lt;Type, char&gt;) {
        std::cout &lt;&lt; &quot;char: &quot; &lt;&lt; arg;
    }
}, v);
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/lejabque/cpp-notes/blob/master/src/19_lambdas_type_erasure.md">cpp-notes/19_lambdas_type_erasure.md at master · lejabque/cpp-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h2>
<p>Если поток не завершил работу, не вызваны методы <code>join()</code> или <code>detach()</code>, но его деструктор <code>thread</code> уже запущен, то программа аварийно завершится вызовом <code>std::terminate</code>.</p>
<p>После успешного вызова на потоке методов <code>join()</code> или <code>detach()</code> метод <code>joinable()</code> будет возвращать ложь.</p>
<p>Вызов метода <code>join()</code> на одном и том же объекте <code>thread</code> из разных потоков - это undefined behavior, в том числе потому что нельзя делать <code>join()</code> потоку, который возвращает <code>joinable()</code> == <code>false</code>. Это приводит к генерации исключения.</p>
<p>Если вам действительно нужно дождаться выполнения потока из разных потоков, то можно это делать более чистыми способами.</p>
<p>Что случится с <code>detached</code>-потоками, когда программа выйдет из main?</p>
<p>Их исполнение будет приостановлено ОС, память освобождена (но не через деструкторы, а просто). Необходимо сделить за тем, что происходит в отсоединенных потоках, чтобы после завершения программы файлы не оставались полузаписанными и shared-память не становилась поломанной. Ресурсы наподобие блокировок на файл будут освобождены самой ОС.</p>
<h2 id="stdconditional_variable"><a class="header" href="#stdconditional_variable">std::conditional_variable</a></h2>
<p>Важно знать, что <code>conditional_variable</code> иногда может просыпаться и без вызова <code>.notify_one()</code>, поэтому более безопасный код будет выглядеть так:</p>
<pre><code class="language-cpp">bool signaled = false;

// start background threads...
// someone will set signaled as true, then call cv.notify_one()

{
    std::unique_lock&lt;std::mutex&gt; lock(mutex);
    while (!signaled) {
        cv.wait(lock);
    }
    signaled = false;
}
</code></pre>
<h2 id="false-sharing"><a class="header" href="#false-sharing">False-sharing</a></h2>
<p>Существует два типа разделения кэш-линий: true sharing и false sharing.</p>
<p>True sharing - это когда потоки имеют доступ к одному и тому же объекту памяти, например, общей переменной или примитиву синхронизации.</p>
<p>False sharing - это доступ к разным данным, но по каким-то причинам оказавшимся в одной кэш-линии процессора.</p>
<p>И тот, и другой случай вредит производительности из-за необходимости аппаратной синхронизации кэш-памяти процессора, однако если первый случай часто неизбежен, то второй можно и нужно исключать.</p>
<p>В случае постоянной модификации данных в условиях false sharing, процессору в соответствии с протоколом когерентности кэша необходимо инвалидировать эту кэш-линию целиком для остальных ядер процессора.</p>
<p>Другой поток уже не сможет пользоваться своими данными, несмотря на то, что они уже лежат в L1 кэше его ядра. Вследствие этого между ядрами происходит синхронизация памяти. Данная операция дорого обходится, если потоки выполняют что-то в цикле - производительность может падать в разы.</p>
<p>На архитектуре x86 в кэш-линию может помещаться 64 байта данных, поэтому если работа происходит с массивом структур данных в многопоточке, то нужно позаботиться о следующих вещах:</p>
<ol>
<li>Выравнивание массива</li>
<li>Наличие подкладки до 64 байт (<code>padding</code>)</li>
</ol>
<hr />
<p>Заимствования:</p>
<p><a href="https://stackoverflow.com/questions/22803600/when-should-i-use-stdthreaddetach">c++ - When should I use std::thread::detach? - Stack Overflow</a></p>
<p><a href="https://habr.com/ru/company/intel/blog/143446/">Делиться не всегда полезно: оптимизируем работу с кэш-памятью / Хабр (habr.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdatomic"><a class="header" href="#stdatomic">std::atomic</a></h2>
<p>Атомарные переменные обеспечивают атомарные взаимодействия с объектом (только я сейчас читаю/пишу в данную переменную, а остальные потоки меня ждут и т.д).</p>
<p>Фишка в том, что на каких-то архитектурах атомарный доступ может быть реализован отдельными инструкциями, а не просто захватом мьютекса или входом в критическую секцию.</p>
<p>Мьютекс - вещь тяжелая, она тянет за собой вызовы к ядру (перепланирование, усыпление потока). Некоторые компиляторы/операционные системы могут соптимизировать блокировку следующим образом: сначала ждать какое-то время в спинлоке, и только затем захватывать мьютекс - при малом ожидании к ядру можно и не обращаться.</p>
<p>Рассмотрим следующий не очень оптимальный код, но жить так можно:</p>
<pre><code class="language-cpp">// overkill
std::mutex m;
int a = 1;

// ...

m.lock();
a += 100;
m.unlock();
</code></pre>
<p>Этот же код с использованием атомарных переменных:</p>
<pre><code class="language-cpp">std::atomic&lt;int&gt; a(1);

// ...

a.fetch_add(100); // равносильно a += 100;
</code></pre>
<p>Правда, атомарные переменные по стандарту вовсе не обязаны быть <code>lock-free</code> (без мьютексов и других блокировок). Проверить, что атомарная переменная является неблокирующей можно с помощью <code>atomic&lt;T&gt;::is_lock_free()</code>.</p>
<p>Единственный атомарный тип с гарантированным по стандарту неблокирующим поведением - <code>atomic_flag</code>.</p>
<pre><code class="language-cpp">// constructor leaves it in uninitialized state until C++20
std::atomic_flag f;

// set to false
f.clear();

// set to true and return previous value
f.test_and_set();

// return value
f.test()
</code></pre>
<p>В языке определены следующие специализации атомиков (некоторые опущены):</p>
<pre><code>atomic_bool   - std::atomic&lt;bool&gt;
atomic_char   - std::atomic&lt;char&gt;
atomic_short  - std::atomic&lt;short&gt;
atomic_int    - std::atomic&lt;int&gt;
atomic_long   - std::atomic&lt;long&gt;
atomic_llong  - std::atomic&lt;long long&gt;
atomic_size_t - std::atomic&lt;std::size_t&gt;
</code></pre>
<p>В отличие от <code>atomic_flag</code> у них побольше методов.</p>
<pre><code class="language-cpp">std::atomic_int a(1337);

// replace value
a.store(445);

// get value
a.load();

// replace value and return previous
a.exchange(42);

// a += 42 and return previous
a.fetch_add(42);

// a += 1 and return previous
a++;

// a += 1 and return new value
++a;

// and so on
</code></pre>
<p>Другие рассматривать не будем, потому что очень сложно.</p>
<p>На самом деле у тех операций, что мы выписали, есть дополнительный второй параметр, который называется <code>memory_order</code>.</p>
<h2 id="stdmemory_order"><a class="header" href="#stdmemory_order">std::memory_order</a></h2>
<p><code>memory_order</code> - это про порядок операций и синхронизацию памяти между потоками.</p>
<p>Внимание: синхронизация процесса выполнения и синхронизация памяти - это, внезапно, разные вещи!</p>
<p>Известно, что компилятор может переупорядочивать наш код, чтобы он работал быстрее, ровно этим же занимается процессор.</p>
<p>Когда мы работаем с многопоточным кодом разбрасываться порядком операций и синхронизацией уже нельзя.</p>
<p>Рассмотрим три типа <code>memory_order</code> - <code>relaxed</code>, <code>release/acquire</code> и <code>sequential consistency</code>.</p>
<h3 id="stdmemory_order_relaxed"><a class="header" href="#stdmemory_order_relaxed">std::memory_order_relaxed</a></h3>
<p>Самый простой для понимания флаг синхронизации памяти — <code>relaxed</code>. Он гарантирует только свойство атомарности операций, при этом не может участвовать в процессе синхронизации данных между потоками.</p>
<p>Свойства:</p>
<ul>
<li>Модификация переменной &quot;появится&quot; в другом потоке не сразу</li>
<li>Поток <code>thread2</code> &quot;увидит&quot; значения <strong>одной и той же</strong> переменной в том же порядке, в котором происходили её модификации в потоке <code>thread1</code></li>
<li>Порядок модификаций разных переменных в потоке <code>thread1</code> не сохранится в потоке <code>thread2</code></li>
</ul>
<p>Можно использовать <code>relaxed</code> модификатор в качестве счетчика или в качестве флага остановки.</p>
<p>Пример неправильного использования <code>relaxed</code>:</p>
<pre><code class="language-cpp">std::string data;
std::atomic&lt;bool&gt; ready{ false };

void thread1() {
    data = &quot;very important bytes&quot;;
    ready.store(true, std::memory_order_relaxed);
}

void thread2() {
    while (!ready.load(std::memory_order_relaxed));
    std::cout &lt;&lt; &quot;data is ready: &quot; &lt;&lt; data &lt;&lt; &quot;\n&quot;; // potentially memory corruption is here
}
</code></pre>
<p>Тут нет гарантий, что поток <code>thread2</code> увидит изменения <code>data</code> ранее, чем изменение флага <code>ready</code>, так как синхронизацию памяти флаг <code>relaxed</code> не обеспечивает.</p>
<h3 id="stdmemory_order_seq_cst"><a class="header" href="#stdmemory_order_seq_cst">std::memory_order_seq_cst</a></h3>
<p>Флаг синхронизации памяти &quot;единая последовательность&quot; (sequential consistency, <code>seq_cst</code>) дает самые строгие свойства:</p>
<ul>
<li>Порядок модификаций разных атомарных переменных в потоке <code>thread1</code> сохранится в потоке <code>thread2</code></li>
<li>Все потоки будут видеть один и тот же порядок модификации всех атомарных переменных. Сами модификации могут происходить в разных потоках</li>
<li>Все модификации памяти (не только модификации над атомиками) в потоке <code>thread1</code>, выполняющим <code>store</code> на атомарной переменной, будут видны после выполнения <code>load</code> этой же переменной в потоке <code>thread2</code> (свойство, как у мьютекса)</li>
</ul>
<p>Таким образом можно представить <code>seq_cst</code> операции, как барьеры памяти, в которых состояние памяти синхронизируется между всеми потоками программы.</p>
<p>Этот флаг синхронизации памяти в C++ используется по умолчанию, так как с ним меньше всего проблем с точки зрения корректности выполнения программы, но <code>seq_cst</code> является дорогой операцией для процессоров.</p>
<h3 id="stdmemory_order_acquire--stdmemory_order_release"><a class="header" href="#stdmemory_order_acquire--stdmemory_order_release">std::memory_order_acquire &amp; std::memory_order_release</a></h3>
<p>Флаг синхронизации памяти <code>acquire/release</code> является более тонким способом синхронизировать данные между парой потоков. Два ключевых слова: <code>memory_order_acquire</code> и <code>memory_order_release</code> работают только в паре над одним атомарным объектом. Рассмотрим их свойства:</p>
<ul>
<li>Модификация атомарной переменной с <code>release</code> будет видна видна в другом потоке, выполняющем чтение этой же атомарной переменной с <code>acquire</code></li>
<li>Все модификации памяти в потоке <code>thread1</code>, выполняющим запись атомарной переменной с <code>release</code>, будут видны после выполнения чтения той же переменной с <code>acquire</code> в потоке <code>thread2</code> (свойство, как у мьютекса)</li>
<li>Процессор и компилятор не могут перенести операции записи в память раньше <code>release</code> операции в потоке <code>thread1</code>, и нельзя перемещать выше операции чтения из памяти, которые были позже <code>acquire</code> операции в потоке <code>thread2</code></li>
</ul>
<p>Используя <code>release</code>, мы даем инструкцию, что данные в этом потоке готовы для чтения из другого потока. Используя <code>acquire</code>, мы даем инструкцию &quot;подгрузить&quot; все данные, которые подготовил для нас первый поток. Но если мы делаем <code>release</code> и <code>acquire</code> на разных атомарных переменных, то получим UB вместо синхронизации памяти.</p>
<p>Рассмотрим mutex на основе спинлока:</p>
<pre><code class="language-cpp">class mutex {
public:
    void lock() {
        bool expected = false;
        while(!_locked.compare_exchange_weak(expected, true, std::memory_order_acquire)) {
            expected = false;
        }
    }
 
    void unlock() {
        _locked.store(false, std::memory_order_release);
    }
 
private:
    std::atomic&lt;bool&gt; _locked;
};
</code></pre>
<p>Обратите внимание, что мьютекс не только обеспечивает эксклюзивный доступ к блоку кода, который он защищает. <strong>Он также делает доступным те изменения памяти, которые были сделаны до вызова</strong> <code>unlock()</code> <strong>в коде, который будет работать после вызова</strong> <code>lock()</code>. Это важное свойство. Иногда может сложиться ошибочное мнение, что мьютекс в конкретном месте не нужен.</p>
<hr />
<p>Заимствования:</p>
<p><a href="https://habr.com/ru/post/517918/">std::atomic. Модель памяти C++ в примерах / Хабр (habr.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Квалификатор-volatile"><a class="header" href="#Квалификатор-volatile">Квалификатор volatile</a></h2>
<p>Квалификатор <code>volatile</code> говорит компилятору, что оптимизировать данную переменную запрещено, и что компилятор никогда не сможет предвидеть или вычислить ее значение заранее.</p>
<pre><code class="language-cpp">volatile int flag = 42;
</code></pre>
<p>Когда это вообще нужно? Рассмотрим следующий пример:</p>
<pre><code class="language-cpp">bool cancel = false;
/* ... */

while (!cancel) {
    /* ... */
}
</code></pre>
<p>Если в теле цикла переменная <code>cancel</code> не меняется, то компилятор может соптимизировать ее проверку, и в цикл мы не войдем никогда.</p>
<p>Таким и должно быть наблюдаемое поведение, если мы не пишем сложной логики, например, если переменная <code>cancel</code> не шарится с другими потоками или процессами, которые могут ее перезаписывать. Использование <code>volatile</code> нужно для предупреждения компилятора, что <em>магические силы</em> могут изменить значение переменной в любой момент и нельзя опираться на то, что в нее было записано в compile-time.</p>
<p>Другой пример:</p>
<pre><code class="language-cpp">unsigned char* pControl = 0xff24;

void f() {
    *pControl = 1;
    *pControl = 0;
    *pControl = 0;
}
</code></pre>
<p>Компилятор может опустить первые две операции присваивания, оставив только последнюю. Когда это может быть вредно? При разработке программ, работающих с <code>Memory mapped IO</code>, то есть взаимодействующих с какими-то железками через оперативную память, или при разработке драйверов, где важно каждое переданное значение.</p>
<p>Использование <code>volatile</code> запрещает перегруппировку инструкций доступа и их оптимизацию, но ни в коем случае не гарантирует атомарности. Чтение <code>volatile</code> переменной при одновременной записи в нее из другого потока или одновременная запись из разных потоков без синхронизации - это data race.</p>
<p>Также использование <code>volatile</code> запрещает использование переменной из регистра - каждое чтение будет связано с загрузкой из оперативной памяти. Это свойство кажется уже очевидным, но тем не менее стоит подчеркнуть, что такое поведение можно использовать для каких-нибудь бенчмарков.</p>
<p>Разумеется, нельзя использовать волатильную переменную со снятым позднее через <code>const_cast</code> квалификатором <code>volatile</code> - это undefined behavior.</p>
<h3 id="Связь-с-квалификатором-const"><a class="header" href="#Связь-с-квалификатором-const">Связь с квалификатором const</a></h3>
<p>Как и <code>const</code>, <code>volatile</code> - это cv-квалификатор, разумеется, поэтому нужно строго понимать, куда писать это слово в объявлении типа.</p>
<p>Пример выше исправляется следующим образом, потому что в функции <code>f</code> мы делаем присвоения в unsigned char&amp;:</p>
<pre><code class="language-cpp">volatile unsigned char* pControl = 0xff24;
</code></pre>
<p>Но если нужна именно <code>volatile</code>-переменная, а не данные по указателю, то это должно писаться следующим образом:</p>
<pre><code class="language-cpp">unsigned char* volatile pControl = 0xff24;
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://en.cppreference.com/w/c/language/volatile">volatile type qualifier - cppreference.com</a></p>
<p><a href="http://alenacpp.blogspot.com/2006/04/volatile.html">Алёна C++: Ключевое слово volatile (alenacpp.blogspot.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Примеры-использования-promise-и-future"><a class="header" href="#Примеры-использования-promise-и-future">Примеры использования promise и future</a></h2>
<pre><code class="language-cpp">// Create a promise
std::promise&lt;int&gt; promise;

// And get its future
std::future&lt;int&gt; future = promise.get_future();

// You can also get a shared future this way, by the way! (Choose one please)
std::shared_future&lt;int&gt; shared_future = promise.get_future();

// Now suppose we passed promise to a separate thread.
// And in the main thread we call...
int val = future.get(); // This will block!

// Until, that is, we set the future's value via the promise
promise.set_value(10); // In the separate thread

// So now in the main thread, if we try to access val...
std::cout &lt;&lt; val &lt;&lt; std::endl;

// Output: 10
</code></pre>
<p>Из заметки про атомики здесь заметна семантика <code>release</code>/<code>acquire</code>. Так и будет - все изменения, сделанные потоком, записавшим в <code>promise</code> значение, будут видны потоку, который прочитал <code>future</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
 
void initiazer(std::promise&lt;int&gt; *promObj) {
    std::cout &lt;&lt; &quot;Inside Thread&quot; &lt;&lt; std::endl;
    promObj-&gt;set_value(35);
}
 
int main() {
    std::promise&lt;int&gt; promiseObj;
    std::future&lt;int&gt; futureObj = promiseObj.get_future();
    std::thread th(initiazer, &amp;promiseObj);
    std::cout &lt;&lt; futureObj.get() &lt;&lt; std::endl;
    th.join();
    return 0;
}
</code></pre>
<h2 id="stdasync"><a class="header" href="#stdasync">std::async</a></h2>
<p>Наипростейший способ использовать <code>async</code> - это просто передать callback-функцию как аргумент и дать системе сделать все за тебя.</p>
<pre><code class="language-cpp">auto future = std::async(some_function, arg_1, arg_2);
</code></pre>
<p>Стоит отметить, что <code>async</code> поддерживает параллелизм, но конструктор по умолчанию может не запускать переданные функции в отдельном потоке. Для того, чтобы функция точно выполнилась в отдельном потоке, необходимо явно сказать <code>async</code> об этом.</p>
<p>Also, since Linux threads run sequentially by default, it's especially important to force the functions to run in separate threads. We'll see how to do that later.</p>
<h3 id="Политики-запуска-stdasync"><a class="header" href="#Политики-запуска-stdasync">Политики запуска std::async</a></h3>
<p>Есть три способа запустить асинхронную задачу:</p>
<ul>
<li><code>std::launch::async</code> - гарантирует запуск в отдельном потоке</li>
<li><code>std::launch::deferred</code> - функция будет вызвана только при вызове <code>get()</code></li>
<li><code>std::launch::async | std::launch::deferred</code> - поведение по умолчанию, отдать на откуп системе.</li>
</ul>
<p>Запуск задачи будет выглядеть так:</p>
<pre><code class="language-cpp">auto future = std::async(std::launch::async, some_function, arg_1, arg_2);
</code></pre>
<p>Еще примеры:</p>
<pre><code class="language-cpp">// Pass in function pointer
auto future = std::async(std::launch::async, some_function, arg_1, arg_2);

// Pass in function reference
auto future = std::async(std::launch::async, &amp;some_function, arg_1, arg_2);

// Pass in function object
struct SomeFunctionObject {
    void operator() (int arg_1) {}
};

auto future = std::async(std::launch::async, SomeFunctionObject(), arg_1);

// Lambda function
auto future = std::async(std::launch::async, [](){});
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://github.com/methylDragon/coding-notes/blob/master/C%2B%2B/07%20C%2B%2B%20-%20Threading%20and%20Concurrency.md">coding-notes/07 C++ - Threading and Concurrency.md at master · methylDragon/coding-notes (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Корутины"><a class="header" href="#Корутины">Корутины</a></h1>
<p>Корутины - это потоки исполнения кода, которые организуются поверх аппаратных (системных) потоков и работают на более высоком уровне - несколько корутин могут по очереди выполнять свой код на одном системном потоке (в зависимости от реализации, корутины могут быть не привязаны к конкретному системному потоку, а например выполнять свой код на пуле потоков).</p>
<p>В отличие от системных потоков, которые переключаются системой в произвольные моменты времени (вытесняющая многозадачность), корутины переключаются вручную в местах, указанных программистом (кооперативная многозадачность).</p>
<p>Простыми словами: корутина может остановиться и передать управление другому потоку (другой корутине), а потом вернуться к текущей инструкции и продолжить выполнение до либо очередной паузы и передачи потока выполнения, либо завершения работы.</p>
<p>В C++20 есть три механизма для работы с корутинами:</p>
<p><code>co_await</code> - ожидание асинхронного результата
<code>co_yield</code> - приостанавливает работу корутины и возвращает какое-то значение
<code>co_return</code> - возвращает значение и завершает работу корутины</p>
<p>Функция является корутиной, если в ней есть хотя бы одна из этих трех команд.</p>
<p>У корутин в С++ есть ограничения:</p>
<ul>
<li>Обязана иметь тип возрата (?)</li>
<li>Не может быть функцией с variadic templates</li>
<li>Не может быть функцией с оператором <code>return</code></li>
<li>Не может быть функцией с автоматичским выведением типа возвращаемого значения (<code>auto</code>)</li>
<li>Не может быть <code>constexpr</code>-функцией</li>
<li>Не может быть конструктором</li>
<li>Не может быть деструктором</li>
<li>Не может быть функцией <code>main</code></li>
</ul>
<p>Есть два типа корутин.</p>
<h3 id="stackless-корутины"><a class="header" href="#stackless-корутины">Stackless-корутины</a></h3>
<p>Таковыми они являются в С++20, и это значит, что корутина при запуске создает на куче пространство, которое будет являться ее памятью для возобновления состояния. Туда она помещает аргументы функции, которые ей передали. Данные, которые ей для возобновления работы не сильно нужны, она складывает в стек вызывающей стороны.</p>
<p>Аргументы по значению она скопирует/помувает, а ссылки останутся ссылками (отсюда следует, что когда корутина вернулась к выполнению кода, у нее может остаться невалидная ссылка, если объект уже уничтожили).</p>
<p>Всю магию переключений между stackless-корутинами компилятор вправе реализовать через конечный автомат и скорее всего так и сделает (в интернете есть пример с огромным оператором <code>switch</code>).</p>
<h3 id="stackfull-корутины"><a class="header" href="#stackfull-корутины">Stackfull-корутины</a></h3>
<p>Такие корутины имеют свой собственный стек и менеджатся хорошо только на уровне ОС. Иначе можно делать магию через свап в фреймах оперативной памяти с помощью ассемблерного кода - что-то об этом упоминал Иван Сорокин на лекциях по C++ Advanced в университете ИТМО.</p>
<p>Stackfull-корутины появились в WinApi уже давно и называются Fiber.</p>
<h2 id="Примеры-использования-корутины"><a class="header" href="#Примеры-использования-корутины">Примеры использования корутины</a></h2>
<pre><code class="language-cpp">X coroutine() {
    co_yield &quot;Hello &quot;;
    co_yield &quot;world&quot;;
    co_return &quot;!&quot;;
}

int main() {
    auto x = coroutine();
    std::cout &lt;&lt; x.next();
    std::cout &lt;&lt; x.next();
    std::cout &lt;&lt; x.next();
    std::cout &lt;&lt; std::endl;
}
</code></pre>
<p>Кажется, что тип X нужно писать самому.</p>
<pre><code class="language-cpp">X foo() {
    co_return 42;
}

X bar() {
    const auto result = foo();
    const int i = co_await result;
    co_return i + 23;
}
</code></pre>
<p>Пример корутины-генератора для факториала:</p>
<pre><code class="language-cpp">X factorial() {
    int a = 1;
    int b = 1;
    for (;;) {
        b *= a;
        a += 1;
        co_yield b;
    }
}
</code></pre>
<hr />
<p>Заимствования:</p>
<p><a href="https://ru.stackoverflow.com/questions/496002/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B-coroutine-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE">c++ - Сопрограммы (корутины, coroutine) - что это? - Stack Overflow на русском</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
