## Reference collapsing rule

Еще до С++11 ввели правило, что ссылка на ссылку - это ссылка без вложенности. В связи с введением `rvalue`-ссылок правило пришлось дополнить.

```
(A&)& -> A&
(A&)&& -> A&
(A&&)& -> A&
(A&&)&& -> A&&
```

Так же в связи с появлением нового типа ссылок стало необходимо распознавать, ссылка какого типа пришла в функцию. Разработчики решили даром синтаксис не терять и не городить новых конструкций, поэтому написание `T&&` от шаблонного типа стало означать новую фичу.

Важный момент! Помните, что

```cpp
int a = 42;

int& b = a; // lvalue-ссылка, имеющая lvalue категорию
const int& b = a; // то же самое

int&& f() {
	return 42;
}

f(); // rvalue-ссылка, имеющая xvalue категорию
int&& b = std::move(a); // rvalue-ссылка, имеющая lvalue категорию

int g(int&& a) { // a - rvalue-ссылка, имеющая lvalue категорию
	return a;
}
```

## Универсальная ссылка

В C++11 правила вывода шаблонных параметров были определеными специальным образом, который позволил сохранять информацию о том, ссылка какого типа в функцию передавалась.

```cpp
template <typename T>
void g(T&& a) {
	f(a);
}

int main() {
	g(42); // rvalue: T -> int, void g(int&&)
	int a;
	g(a); // lvalue: T -> int&, void g(int&)
}
```

Здорово, но как ни крути `int&&` - это теперь именованная ссылка, а значит это не `prvalue` и мувать его напрямую нельзя. Как сохранять тип ссылки при передаче аргументов?

## std::forward

Использование `Perfect forwarding` позволяет сохранять тип ссылки на уровне компиляции.

```cpp

void bar(int& v) {
	std::cout << "lvalue";
}

void bar(int&& v) {
	std::cout << "rvalue";
}

template <typename T>
void foo(T&& v) {
	bar(v);
}

template <typename T>
void foo2(T&& v) {
	bar(std::forward<T>(v));
}

int a = 42;
foo(a);  // out: lvalue
foo(42); // out: lvalue

foo2(a);  // out: lvalue
foo2(42); // out: rvalue

```

Часто `std::forward` применяется вместе с variadic templates.

```cpp
template<typename... Args>
void f(Args&&... args) {
    g(std::forward<Args>(args)...);
}
```
