## Лямбда-функция

Имеет следующий синтаксис:

```cpp
auto lambda = [](int a, int b) -> bool {return a < b;}
```

Полученный объект по сути будет структурой с известным только компилятору уникальным типом, имеющим `operator()` с аргументами, переданными в лямбду.

Вовзращаемый тип можно задать явно через trailing return types, либо довериться компилятору (равносильно типу auto).

Квадратные скобки здесь не просто для красоты - они использутся для захвата переменных из контекста объявления лямбда-функции.

```cpp
int a = 42;

// захват переменной по значению
auto mul = [a](int k) {return k * a;}

// захват переменной по ссылке
auto add = [&a](int k) {return k + a;}

// захват переменной по значению с присвоением нового имени (C++14)
auto sub = [b = a](int k) {return k - b;}

// захват переменной по ссылке с присвоением нового имени (C++14)
auto div = [&b = a](int k) {return k / b;}
```

Но жить веселее, когда конструкции мощнее. Лямбды умеют делать захвать всего контекста по значению/ссылке.

```cpp
int x, y;

[=](){}    // все по значению
[=, &x](){} // все по значению, x - по ссылке

[&](){}    // все по ссылке
[&, x](){} // все по ссылке, x - по значению
```

Более того, если лямбда объявлена в классе, то при захвате всего контекста ей станет доступен `this` экземпляра класса (C++17).

### Свойства лямбд

* имеют оператор вызова
* обладают конструкторами копирования и перемещения
* не могут присваиваться
* незахватывающие лямбды могут конвертиться к указателю на функцию
* при копировании лямбды, копируются все захваченные по значению переменные, а захват по ссылке не продлевает время жизни объектов. Такой код работает неправильно:

```cpp
auto foo() {
    std::vector<int> v;
    return [&v]() {
        // ...
    };
} // v уничтожится при выходе из функции, обращение внутри лямбды - UB
```

### Шаблонные лямбды

Может ли лямбда быть шаблонной? 

Чтобы говорить об этом, нужно понимать, шаблон у чего имеется в виду - у класса или у `operator()`.

```cpp
template <typename T>
struct less {
    bool operator()(T const& a, T const& b) const {
        return a < b;
    }  
};

struct polymorphic_less {
    template <typename T>
    bool operator()(T const& a, T const& b) const {
        return a < b;
    }  
};
```

Делать лямбду шаблонной, как шаблонный класс, смысла не имеет, так как мы её создаём один раз.

В C++20 можно писать лямбдам шаблонные параметры:

```cpp
int main() {
    auto less = []<typename T>(T a, T b) {return a < b;};
    bool val = less(42, 43);
}
```

До C++20 существовал `auto` для типов аргументов (не только для лямбд, но и для обычных функций). По сути, это означало, что для аргумента неявно создаётся шаблонный параметр:

```cpp
void foo(auto a) {}

int main() {
    foo(1.0);
    foo<int>(42); // можно даже явно передать тип
}
```

Такой синтаксис имеет ограничение - нельзя иметь параметры только одного типа, так как на каждый создаётся свой шаблонный параметр:

```cpp
void foo(auto a, auto b) {};

template <typename A, typename B>
void foo(A a, B b) {}; // эквивалентно
```

### Рекурсивный вызов лямбды

Пример ниже выдаст ошибку компиляции:

```cpp
auto factorial = [&factorial](int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
};

```

`error: use of 'factorial' before deduction of 'auto'`, что говорит нам о том, что тип `auto` еще не был выведен, поэтому пользоваться им нельзя.

#### Вариант 1

```cpp
std::function<int(int)> factorial;

factorial = [&](int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
};

std::cout << factorial(4);
```

#### Вариант 2

```cpp
auto factorial = [](int n, auto&& f) -> int {
    return (n <= 1 ? 1 : n * f(n - 1, f));
};

std::cout << factorial(4, factorial);
```


---

Заимствования:

[cpp-notes/19_lambdas_type_erasure.md at master · lejabque/cpp-notes (github.com)](https://github.com/lejabque/cpp-notes/blob/master/src/19_lambdas_type_erasure.md)
