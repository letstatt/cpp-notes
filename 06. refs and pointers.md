# Ссылки и указатели

Ссылка - это псевдоним к определенной ранее переменной.
Указатель - это объект, значением которого является адрес ячейки памяти.

Разница?

#### Инициализация

Ссылку обязательно инициализировать. Она не может указывать вникуда или быть пустой, в отличие от указателя, которому задавать начальное значение необязательно.

#### Изменение значения

Ссылка не может быть переопределена, вместо этого присвоится значение переменной, на которую ссылка ссылается, если она не константная. Присваивать же новое значение указателю можно, если он не константный.

#### Взятие адреса

Ссылка - псевдоним к переменной, а не объект. Взятие адреса от ссылки будет возвращать адрес объекта, на который ссылка ссылается. Взятие же адреса указателя будет возвращать адрес указателя, а не объекта, на который указатель ссылается.

По стандарту ссылка - не объект, но при определенных условиях, ссылки могут компилироваться в указатели.

Рекомендация: используйте ссылки вместо указателей, если вам не нужно передавать пустое значение (читай, `nullptr`).

## Интересное про ссылки

### Краткие факты

* Ссылки на ссылку не бывает. Они коллапсируют в одну.
* Ссылки типа `void` не бывает.
* Ссылка может продлить время жизни объекта, если это `lvalue`-ссылка на const или `rvalue`-ссылка.

### Dangling reference

Ссылки были созданы, чтобы сделать указатели безопаснее, но даже их можно сломать.

```cpp
#include <iostream>

int& bar() {
    int n = 10;
    return n;
}

int main() {
    int& i = bar();
    std::cout << i << std::endl;
}
```

Функция `bar()` вернет ссылку на локальную переменную, которая уничтожится при выходе из нее. Соответственно, такая ссылка будет невалидной и операции с ней - это undefined behavior.

Но вот так делать можно, конечно.

```cpp
#include <iostream>

const int& bar(const int& a) {
    return a;
}

int main() {
    const int& i = bar(42);
    std::cout << i << std::endl;
}
```

### Передача массива по ссылке

Не секрет, что для работы с массивами можно использовать указатели, но в определение типа таких указателей не входит размер массива. При передаче указателя в функцию, информацию о размере нужно передавать отдельно. Чтобы с этим не париться, можно сделать ссылку на массив с фиксированным размером.

```cpp
#include <type_traits>

// Конвертирует строковый литерал в число
template <size_t N>
int convert(const char (&in)[N]) {
	int res = 0;
	for (const char * c = in; *c; ++c) {
		(res *= 10) += *c - '0';
	}
	return res;
}

// Вычисляет длину массива
template <typename T, size_t N>
size_t len(T (&a)[N]) {
	return n;
}
```

Остальные фишки ссылок будут в другой заметке.

## Интересное про указатели

### Краткие факты

* Можно сделать указатель на указатель на указатель ...
* Поддерживают арифметику (только указатели в рамках одного массива. остальное - UB)

### Указатели на массивы фиксированной длины

```cpp
int (*a)[2]; // create pointer to int[2]
int b[2];
int c[2];

a = new int[2]; // compile error (returns int*)
a = &b; // OK (returns int(*)[2])
a = (int(*)[2]) (new int[2]); // OK
a = &c; // compile error (returns int(*)[3])
```

### Многомерные массивы на стеке

При объявлении многомерных массивов на стеке память выделяется непрерывно, что позволяет компилятору при индексации делать прыжок по указателю единожды.

```cpp
int x[10][10]; // выделенный на стеке многомерный массив
int a = x[2][3]; // один прыжок
```

Но при индексации от указателя на него программа будет совершать честные прыжки в количестве измерений.

```cpp
int **y = x;
int b = y[2][3]; // два прыжка
```

### Как читать мешанину со словом const

Ключевое слово `const` относится к тому, что слева, если не в начале строки, иначе к тому, что справа.

```cpp
int a = 42;
const int b; // нет инициализации, compile error
const int c = a; // константный int
int const d = a; // то же самое

const int * e = &a; // изменяемый указатель на неизменяемый int
int const * f = &a; // то же самое

int * const g = &a; // неизменяемый указатель на изменяемый int
const int * const h = &a; // константный указатель на константу
```

### Указатель на функцию

```cpp
double sum(int a, long b) {
	return a + b;
}

double (*ptr)(int, long) = sum;
double (*ptr)(int, long) = &sum; // эквивалентно

double c = (*ptr)(1, 2l);
double c = ptr(1, 2l); // эквивалентно
```

